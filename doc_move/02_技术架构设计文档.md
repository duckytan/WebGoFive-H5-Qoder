# 02 - 技术架构设计文档

> **版本**: v1.2.0  
> **目标**: 说明H5五子棋的系统架构、模块划分、数据流、关键设计决策

---

## 1. 技术栈选型

### 1.1 核心技术

| 技术 | 版本/规范 | 用途 |
|------|-----------|------|
| HTML5 | - | 页面结构、Canvas元素 |
| CSS3 | - | 样式、布局、动画 |
| JavaScript | ES6+ | 业务逻辑、游戏算法 |
| Canvas 2D API | - | 棋盘和棋子渲染 |
| LocalStorage | - | 本地数据持久化 |

**为什么不使用框架/构建工具？**
- **简单性**: 零配置，双击即可运行
- **可理解性**: 没有黑盒，所有逻辑一目了然
- **可移植性**: 任何支持HTML5的浏览器都能运行
- **教学友好**: 适合学习原生Web开发

### 1.2 模块导出方式

**采用window全局导出**，所有模块通过`window.*`挂载：

```javascript
// 模块定义
class GomokuGame {
    // ...
}

// 导出到全局
if (typeof window !== 'undefined') {
    window.GomokuGame = GomokuGame;
}
```

**优势**:
- 浏览器原生支持，无需模块加载器
- 加载顺序清晰直观
- 调试方便（可直接在Console访问）

**注意事项**:
- 必须严格控制加载顺序
- 避免命名冲突
- 大型项目不推荐此方式

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────┐
│              InterfaceDemo (UI层)            │
│  (demo.js - 界面交互、模式管理、事件分发)       │
└────────────────┬────────────────────────────┘
                 │
    ┌────────────┼────────────┐
    │            │            │
┌───▼────┐  ┌───▼────┐  ┌───▼─────┐
│Renderer│  │ Core   │  │Auxiliary│
│(渲染层) │  │(核心层) │  │ (辅助层) │
└────────┘  └────────┘  └─────────┘
```

### 2.2 分层架构

#### 工具层 (Foundation)
```
utils.js (GameUtils)
└── 提供通用工具函数
    ├── 消息提示
    ├── 时间格式化
    ├── 文件下载
    ├── LocalStorage操作
    └── 节流/防抖
```

#### 核心层 (Core)
```
game-core.js (GomokuGame)
├── 棋盘状态管理 (15x15数组)
├── 游戏规则引擎
│   ├── 落子验证
│   ├── 胜负判定
│   └── 禁手检测
├── 历史记录管理
├── 模式切换 (PvP/PvE/EvE/VCF)
└── 数据导出/导入

ai-advanced.js (AdvancedAI)
├── AI决策引擎
│   ├── Minimax + Alpha-Beta
│   ├── 威胁分析
│   ├── VCF搜索
│   └── 评估函数
├── 开局库
└── 难度调节
```

#### 渲染层 (View)
```
board-renderer.js (SimpleBoardRenderer)
├── Canvas渲染
│   ├── 棋盘网格
│   ├── 棋子（黑白）
│   ├── 悬停预览
│   ├── 禁手高亮
│   └── 提示标记
├── 鼠标/触摸事件处理
└── 坐标转换
```

#### 辅助层 (Auxiliary)
```
game-save-load.js (GameSaveLoad)
├── 棋局保存/加载
├── 自动保存
├── 数据验证
└── 版本兼容

game-replay.js (GameReplay)
├── 回放控制
├── 播放速度
├── 步骤导航
└── 导出功能

vcf-practice.js (VCFPracticeManager)
├── 题库管理 (40题)
├── 走法验证
├── AI防守
└── 进度追踪
```

#### UI层 (Interface)
```
demo.js (InterfaceDemo)
├── 界面状态管理
├── 事件监听与分发
├── 模式切换协调
├── 用户交互处理
└── 模态框管理
```

---

## 3. 核心模块详解

### 3.1 GomokuGame (game-core.js)

**职责**: 游戏核心引擎，管理状态和规则

**核心属性**:
```javascript
class GomokuGame {
    board          // 15x15二维数组 [y][x]，0=空 1=黑 2=白
    boardSize      // 15
    currentPlayer  // 1=黑 2=白
    gameStatus     // 'ready' | 'playing' | 'finished'
    gameMode       // 'PvP' | 'PvE' | 'EvE' | 'VCF_PRACTICE'
    winner         // null | 0=平局 | 1=黑胜 | 2=白胜
    moves          // 历史记录 [{x,y,player,timestamp,step}]
    aiDifficulty   // 'BEGINNER' | 'NORMAL' | 'HARD' | 'HELL'
}
```

**核心方法**:
```javascript
placePiece(x, y)           // 落子，返回 {success, error?, gameOver?, winner?}
undo()                     // 悔棋
reset()                    // 重置游戏
checkWin(x, y)             // 胜负判定
checkForbidden(x, y)       // 禁手检测
getBoardState()            // 获取棋盘副本
exportData()               // 导出完整游戏数据
loadFromData(data)         // 从数据恢复
```

**数据流**:
```
用户点击
  ↓
boardRenderer.placePiece(x,y)
  ↓
game.placePiece(x,y)
  ├→ 验证合法性
  ├→ 检查禁手 (黑棋)
  ├→ 更新棋盘
  ├→ 记录历史
  ├→ 检查胜负
  └→ 切换玩家
  ↓
返回结果 {success, ...}
  ↓
demo.handleMoveResult()
  ├→ 更新UI
  ├→ 触发AI (PvE/EvE)
  └→ 显示消息
```

### 3.2 SimpleBoardRenderer (board-renderer.js)

**职责**: Canvas渲染和用户交互

**渲染流程**:
```javascript
render() {
    clearCanvas()
    drawBoard()              // 背景+网格
    drawStarPoints()         // 星位标记
    drawPieces()             // 所有棋子
    drawHoverPreview()       // 悬停预览
    drawForbiddenHighlight() // 禁手高亮
    drawHintHighlight()      // 提示高亮
    drawLastMove()           // 最后一手标记
}
```

**事件处理**:
```javascript
canvas.onclick → 
  转换鼠标坐标为棋盘坐标 →
  判断模式：
    - VCF_PRACTICE → demo.handleVCFPracticeMove(x,y)
    - 其他 → game.placePiece(x,y)

canvas.onmousemove →
  更新hoverX, hoverY →
  render()
```

**坐标转换**:
```javascript
// 鼠标坐标 → 棋盘坐标
gridX = Math.round((mouseX - padding) / cellSize)
gridY = Math.round((mouseY - padding) / cellSize)

// 棋盘坐标 → Canvas坐标
canvasX = padding + gridX * cellSize
canvasY = padding + gridY * cellSize
```

### 3.3 InterfaceDemo (demo.js)

**职责**: UI协调器，连接所有模块

**初始化流程**:
```javascript
constructor() {
    检查依赖模块
    初始化状态
    绑定事件监听
    启动定时器
    初始化扩展模块 (SaveLoad, Replay, VCF)
}
```

**关键方法**:
```javascript
handleMoveResult(result)   // 处理落子结果
executeAIMove()           // 执行AI落子
handleVCFPracticeMove()   // 处理VCF练习落子
toggleGameMode()          // 切换游戏模式
updateModeDisplay()       // 更新模式显示
canPlacePiece()          // 判断是否可落子
```

**模式管理**:
```javascript
availableModes = ['PvE', 'PvP', 'EvE', 'VCF_PRACTICE']

toggleGameMode() {
    currentIndex = (currentIndex + 1) % modes.length
    gameMode = modes[currentIndex]
    game.gameMode = gameMode     // 同步到game
    updateModeDisplay()
    reset()
}
```

### 3.4 AdvancedAI (ai-advanced.js)

**职责**: AI决策引擎

**搜索算法层次**:
```
Level 1: 简单评分 (BEGINNER)
  → 候选点评分 + 随机性

Level 2: Minimax + Alpha-Beta (NORMAL)
  → 深度3, 候选点限制20

Level 3: 威胁分析 + 迭代加深 (HARD)
  → 深度4, 威胁序列搜索

Level 4: VCF + 完整搜索 (HELL)
  → 深度5, VCF攻防, 开局库
```

**决策流程 (HELL)**:
```javascript
getMove(difficulty='HELL') {
    1. 查开局库 (前2手)
    2. 找必胜点
    3. 挡对手必胜点
    4. VCF攻击搜索
    5. VCF防守搜索
    6. 威胁序列分析
    7. Alpha-Beta深度搜索
    8. 降级简单策略
}
```

**VCF搜索**:
```javascript
searchVCF(player, depth=0, maxDepth=10) {
    if (depth >= maxDepth) return null
    
    找所有冲四点
    for each 冲四点:
        临时落子
        if (立即获胜) return 冲四点
        
        找所有防守点
        for each 防守点:
            临时防守
            递归 searchVCF(depth+1)
            撤销防守
            
            if (有防守失败) break
        
        if (所有防守都失败) return 冲四点
        撤销落子
    
    return null
}
```

---

## 4. 数据流与状态管理

### 4.1 游戏状态流转

```
[ready] ──placePiece──> [playing] ──checkWin──> [finished]
   ↑                                                  │
   └─────────────────reset()─────────────────────────┘
```

### 4.2 模式切换流程

```
用户点击"切换模式"
  ↓
demo.toggleGameMode()
  ├→ 计算下一模式
  ├→ 更新 demo.gameMode
  ├→ 更新 game.gameMode
  ├→ 调用 updateModeDisplay()
  │   ├→ 更新按钮文本
  │   ├→ 显示/隐藏AI面板
  │   └→ 显示/隐藏VCF面板
  └→ 调用 startNewGame()
      └→ game.reset()
          └→ boardRenderer.render()
```

### 4.3 VCF练习数据流

```
startVCFPractice(level)
  ↓
practiceManager.getRandomPuzzle(level)
  ↓
game.loadCustomState(puzzle.initialBoard)
  ↓
boardRenderer.render()
  ↓
用户落子
  ↓
demo.handleVCFPracticeMove(x, y)
  ├→ practiceManager.validateMove(x, y)
  │   ├→ 正确: advanceStep()
  │   └→ 错误: 提示正确位置
  ├→ 自动AI防守 (延迟400ms)
  ├→ 检查是否完成
  └→ 更新进度显示
```

---

## 5. 关键设计决策

### 5.1 为什么棋盘是board[y][x]而不是board[x][y]？

**原因**: 二维数组习惯上第一维表示行（Y轴），第二维表示列（X轴）
**优势**: 遍历时先行后列，符合视觉习惯
**注意**: 访问时必须使用`board[y][x]`，否则会导致坐标混乱

### 5.2 为什么禁手检测要"临时落子"？

```javascript
checkForbidden(x, y) {
    this.board[y][x] = player  // 临时落子
    const result = countOpenThrees(x, y)
    this.board[y][x] = 0       // 恢复
    return result
}
```

**原因**: 活三/活四判定需要"假设这个位置有子"才能分析形态  
**风险**: 如果忘记恢复会导致棋盘状态错误  
**保障**: 每次检测后必须恢复，使用try-finally保证

### 5.3 为什么AI思考要延迟？

```javascript
setTimeout(() => {
    executeAIMove()
}, thinkTime)
```

**原因**:
1. 给用户反应时间，显示"AI思考中"
2. 避免瞬间落子导致用户困惑
3. 模拟人类思考过程

**时间设置**:
- BEGINNER: 500ms
- NORMAL: 1000ms
- HARD: 1500ms
- HELL: 1800ms

### 5.4 为什么VCF练习要固定地狱难度防守？

**原因**: VCF题目是精心设计的必胜局面，如果AI防守太弱，玩家走错了也能赢，失去练习意义  
**实现**: `game.aiDifficulty = 'HELL'` 且AI使用完整VCF防守算法

### 5.5 为什么回放系统模仿音乐播放器？

**原因**: 用户熟悉音乐播放器UI，学习成本低  
**设计**:
- 播放/暂停按钮
- 进度条拖动
- 速度调节 (0.5x / 1x / 2x / 3x)
- 步骤列表（类似播放列表）

---

## 6. 模块依赖图

```
┌──────────────┐
│  GameUtils   │ (无依赖)
└───────┬──────┘
        │
┌───────▼──────────┐
│  GomokuGame      │
└───────┬──────────┘
        │
        ├──────────────────────┬──────────────────┬──────────────────┐
        │                      │                  │                  │
┌───────▼──────────┐  ┌───────▼──────┐  ┌───────▼────────┐  ┌──────▼────────┐
│  AdvancedAI      │  │ BoardRenderer │  │ GameSaveLoad   │  │ GameReplay    │
└──────────────────┘  └───────┬───────┘  └────────────────┘  └───────────────┘
                              │
                      ┌───────▼──────────┐
                      │ VCFPracticeManager│
                      └───────┬───────────┘
                              │
                      ┌───────▼──────────┐
                      │  InterfaceDemo   │
                      └──────────────────┘
```

**加载顺序 (index.html)**:
```html
<script src="js/utils.js"></script>
<script src="js/game-core.js"></script>
<script src="js/ai-advanced.js"></script>
<script src="js/board-renderer.js"></script>
<script src="js/game-save-load.js"></script>
<script src="js/game-replay.js"></script>
<script src="js/vcf-practice.js"></script>
<script src="js/demo.js"></script>
```

---

## 7. 性能优化策略

### 7.1 Canvas渲染优化
- 仅在状态变化时重绘
- 使用requestAnimationFrame
- 高频事件使用节流

### 7.2 AI搜索优化
- Alpha-Beta剪枝减少节点
- 候选点限制（只搜索2格内）
- 迭代加深搜索
- 开局库减少计算

### 7.3 禁手检测优化
- 只对黑棋检测
- 优先检查长连（最快）
- 缓存线性签名（避免重复计算）

### 7.4 内存优化
- 避免深拷贝，使用引用
- 定时清理LocalStorage
- 限制历史记录数量（可选）

---

## 8. 错误处理策略

### 8.1 模块加载错误

```javascript
// ModuleDependencyChecker 检查依赖
const check = ModuleDependencyChecker.checkDependencies([
    'GameUtils', 'GomokuGame', 'SimpleBoardRenderer'
])

if (!check.success) {
    throw new Error(`缺少依赖: ${check.missing.join(', ')}`)
}
```

### 8.2 落子错误

```javascript
placePiece(x, y) {
    if (!this.isValidPosition(x, y)) {
        return {
            success: false,
            error: '坐标超出范围',
            code: 'INVALID_POSITION'
        }
    }
    // ...
}
```

### 8.3 存档错误

```javascript
loadFromData(data) {
    try {
        validateGameData(data)
        // 恢复逻辑
    } catch (error) {
        console.error('加载失败:', error)
        GameUtils.showMessage('数据格式错误', 'error')
        return false
    }
}
```

---

## 9. 扩展性设计

### 9.1 新增AI难度

```javascript
// 在 game-core.js 或 ai-advanced.js 中
const AI_LEVELS = {
    BEGINNER: {...},
    NORMAL: {...},
    HARD: {...},
    HELL: {...},
    ULTIMATE: {      // 新增
        name: '终极',
        maxDepth: 7,
        useDeepLearning: true,
        ...
    }
}
```

### 9.2 新增游戏模式

```javascript
// 在 demo.js 中
this.availableModes = ['PvE', 'PvP', 'EvE', 'VCF_PRACTICE', 'VCT_PRACTICE']

// 在 game-core.js 中添加模式逻辑
```

### 9.3 新增练习题库

```javascript
// 在 vcf-practice.js 中
generateLevel5Puzzles() {
    // 返回更高难度题目
}
```

---

## 10. 测试策略

### 10.1 单元测试

```javascript
// 测试禁手检测
function testForbidden() {
    const game = new GomokuGame()
    // 设置特定棋局
    game.board[7][7] = 1
    game.board[7][8] = 1
    // ...
    const result = game.checkForbidden(7, 9)
    assert(result.isForbidden === true, '应检测到三三禁手')
}
```

### 10.2 集成测试

```javascript
// 测试完整对局流程
function testFullGame() {
    // 1. 初始化
    // 2. 连续落子
    // 3. 验证胜负
    // 4. 测试悔棋
    // 5. 测试保存/加载
}
```

### 10.3 性能测试

```javascript
// 测试AI响应时间
function testAIPerformance() {
    const start = performance.now()
    ai.getMove('HELL')
    const elapsed = performance.now() - start
    assert(elapsed < 3000, 'HELL难度应<3秒')
}
```

---

**下一步推荐阅读**: [03_游戏规则与AI算法要点.md](./03_游戏规则与AI算法要点.md)
