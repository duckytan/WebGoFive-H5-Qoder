# 02 技术架构设计文档

## 文档目的

详细描述H5五子棋项目的技术架构、模块设计、数据流、关键算法，为AI重建项目提供完整的技术蓝图。

---

## 1. 技术栈概览

### 1.1 核心技术选型

| 技术领域 | 选型 | 版本/标准 | 选择理由 |
|---------|------|-----------|----------|
| **开发语言** | JavaScript | ES6+ (ES2015-2020) | 类语法、箭头函数、Promise、async/await |
| **UI结构** | HTML5 | 语义化标签 | 单页应用，所有UI在一个HTML |
| **样式** | CSS3 | CSS变量、Flexbox、Grid | 响应式布局、主题可定制 |
| **渲染引擎** | Canvas 2D | HTML5 Canvas API | 高性能图形绘制 |
| **状态管理** | 原生JS | Class实例 | 无需Redux等库，简单可控 |
| **数据持久化** | LocalStorage | Web Storage API | 离线可用，自动保存 |
| **文件处理** | FileReader | File API | 文件导入导出 |
| **模块系统** | Window全局对象 | 浏览器原生 | 无需Webpack，直接script加载 |
| **构建工具** | 无 | - | 零依赖，零构建，开箱即用 |

**技术决策原则**：
1. **零依赖**：不使用任何npm包或外部库
2. **零构建**：不使用Webpack、Babel等构建工具
3. **原生优先**：使用浏览器原生API和特性
4. **向后兼容**：支持Chrome 60+、Firefox 55+、Safari 12+

### 1.2 不使用的技术（及原因）

| 技术 | 为什么不用 |
|------|-----------|
| React/Vue/Angular | 增加复杂度，违背零依赖原则 |
| TypeScript | 需要编译，违背零构建原则 |
| Webpack | 需要构建，增加开发成本 |
| npm/yarn | 无外部依赖，不需要包管理 |
| jQuery | 现代浏览器原生API足够，无需jQuery |
| Lodash | 自己实现工具函数，代码量小 |
| Moment.js | 原生Date对象足够简单场景 |

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        浏览器环境                             │
│  ┌──────────────────────────────────────────────────────┐   │
│  │                   index.html (UI层)                   │   │
│  │  ┌────────────┐  ┌───────────┐  ┌─────────────────┐  │   │
│  │  │ Header栏   │  │ Sidebar   │  │ Game Board      │  │   │
│  │  │ (按钮/标题) │  │ (面板/设置)│  │ (Canvas 600x600)│  │   │
│  │  └────────────┘  └───────────┘  └─────────────────┘  │   │
│  │  ┌────────────────────────────────────────────────┐  │   │
│  │  │ Modals (弹窗：结果/设置/帮助)                    │  │   │
│  │  └────────────────────────────────────────────────┘  │   │
│  └──────────────────────────────────────────────────────┘   │
│         ↓ 事件绑定                              ↑ DOM更新      │
│  ┌──────────────────────────────────────────────────────┐   │
│  │              JavaScript 模块层 (8个模块)              │   │
│  ├──────────────────────────────────────────────────────┤   │
│  │  ┌─────────────────────────────────────────────┐     │   │
│  │  │  demo.js (InterfaceDemo) - UI主控制器       │     │   │
│  │  │  - 事件监听与分发                            │     │   │
│  │  │  - 模式切换与状态同步                         │     │   │
│  │  │  - 协调各模块交互                            │     │   │
│  │  └──────────────┬──────────────────────────────┘     │   │
│  │                 │                                     │   │
│  │  ┌──────────────┼──────────────────────────┐         │   │
│  │  │              ↓                          │         │   │
│  │  │  ┌─────────────────────┐  ┌──────────────────┐   │   │
│  │  │  │ game-core.js        │  │board-renderer.js │   │   │
│  │  │  │ (GomokuGame)        │  │(BoardRenderer)   │   │   │
│  │  │  │ - 棋盘状态管理       │  │ - Canvas绘制     │   │   │
│  │  │  │ - 规则判定           │  │ - 事件处理       │   │   │
│  │  │  │ - AI算法             │  │ - 高亮渲染       │   │   │
│  │  │  └─────────┬───────────┘  └──────────────────┘   │   │
│  │  │            │                                      │   │
│  │  │  ┌─────────┴─────────┐                           │   │
│  │  │  │                   ↓                           │   │
│  │  │  │      ┌──────────────────┐                     │   │
│  │  │  │      │ ai-advanced.js   │                     │   │
│  │  │  │      │ (AdvancedAI)     │                     │   │
│  │  │  │      │ - 开局库         │                     │   │
│  │  │  │      │ - VCF搜索        │                     │   │
│  │  │  │      │ - 威胁序列       │                     │   │
│  │  │  │      └──────────────────┘                     │   │
│  │  │  │                                                │   │
│  │  │  ├─────────────────────────────┐                 │   │
│  │  │  │                             ↓                 │   │
│  │  │  │  ┌──────────────┐  ┌──────────────────┐      │   │
│  │  │  │  │vcf-practice.js│  │ game-save-load.js│     │   │
│  │  │  │  │(VCFManager)   │  │ (GameSaveLoad)   │     │   │
│  │  │  │  │ - 40道题库    │  │ - 保存/加载      │     │   │
│  │  │  │  │ - 进度追踪    │  │ - 自动保存       │     │   │
│  │  │  │  └──────────────┘  └──────────────────┘      │   │
│  │  │  │                                                │   │
│  │  │  │  ┌──────────────┐  ┌──────────────────┐      │   │
│  │  │  │  │game-replay.js │  │ utils.js         │     │   │
│  │  │  │  │ (GameReplay)  │  │ (GameUtils)      │     │   │
│  │  │  │  │ - 回放控制    │  │ - 工具函数       │     │   │
│  │  │  │  └──────────────┘  └──────────────────┘      │   │
│  │  └──────────────────────────────────────────────────┘   │
│  │                              ↓                           │
│  │  ┌──────────────────────────────────────────────────┐   │
│  │  │           LocalStorage (持久化层)                 │   │
│  │  │  - gomoku_auto_save (自动保存)                    │   │
│  │  │  - gomoku_settings (用户设置)                     │   │
│  │  │  - vcf_practice_progress_v3 (VCF进度)            │   │
│  │  └──────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 分层架构

#### 第1层：表现层 (Presentation Layer)
```
index.html + style.css + animations.css
│
├─ 职责：
│  ├─ UI结构定义（HTML）
│  ├─ 样式和布局（CSS）
│  ├─ 动画效果（CSS动画）
│  └─ 用户输入收集（表单、按钮）
│
└─ 特点：
   ├─ 单一HTML文件，所有UI元素预定义
   ├─ CSS变量实现主题可定制
   ├─ 无逻辑，纯视图
```

#### 第2层：控制层 (Controller Layer)
```
demo.js (InterfaceDemo)
│
├─ 职责：
│  ├─ 监听UI事件（点击、按键）
│  ├─ 调用业务逻辑模块
│  ├─ 更新DOM状态
│  ├─ 协调各模块通信
│  └─ 模式切换管理
│
└─ 特点：
   ├─ UI和逻辑的桥梁
   ├─ 不包含业务规则
   ├─ 负责状态同步
```

#### 第3层：业务逻辑层 (Business Logic Layer)
```
game-core.js (GomokuGame)
│
├─ 职责：
│  ├─ 游戏规则实现（五连判定、禁手检测）
│  ├─ 游戏状态管理（棋盘、历史、玩家）
│  ├─ AI算法实现（4级难度）
│  ├─ 数据导入导出
│  └─ 核心算法逻辑
│
└─ 特点：
   ├─ 纯逻辑，无UI依赖
   ├─ 可独立测试
   ├─ 是整个项目的核心
```

#### 第4层：渲染层 (Rendering Layer)
```
board-renderer.js (SimpleBoardRenderer)
│
├─ 职责：
│  ├─ Canvas绘制（棋盘、棋子、高亮）
│  ├─ 用户交互处理（点击、悬停）
│  ├─ 坐标转换（像素 ↔ 棋盘坐标）
│  └─ 视觉反馈渲染
│
└─ 特点：
   ├─ 专注图形绘制
   ├─ 与game-core松耦合
   ├─ 可替换渲染方式（如SVG）
```

#### 第5层：辅助模块层 (Utility Layer)
```
utils.js (GameUtils)
vcf-practice.js (VCFPracticeManager)
ai-advanced.js (AdvancedAI)
game-save-load.js (GameSaveLoad)
game-replay.js (GameReplay)
│
├─ 职责：
│  ├─ 通用工具函数（格式化、存储）
│  ├─ 特定功能模块（VCF、回放）
│  ├─ 高级AI算法（深度搜索）
│  └─ 数据持久化
│
└─ 特点：
   ├─ 功能独立
   ├─ 可插拔设计
   ├─ 可选依赖
```

#### 第6层：数据持久化层 (Persistence Layer)
```
LocalStorage
│
├─ 存储内容：
│  ├─ gomoku_auto_save (当前棋局自动保存)
│  ├─ gomoku_settings (用户设置)
│  ├─ vcf_practice_progress_v3 (VCF练习进度)
│  └─ gomoku_history (对局历史记录)
│
└─ 特点：
   ├─ 浏览器原生API
   ├─ 5MB存储限制
   ├─ 跨会话持久化
```

---

## 3. 核心模块设计

### 3.1 game-core.js (GomokuGame)

#### 职责
五子棋游戏的核心引擎，负责所有游戏逻辑、规则判定和AI算法。

#### 关键属性
```javascript
class GomokuGame {
    // 棋盘状态
    boardSize: number = 15
    board: number[][] = Array(15).fill().map(() => Array(15).fill(0))
    
    // 游戏状态
    gameStatus: 'ready' | 'playing' | 'finished'
    currentPlayer: 1 | 2  // 1=黑，2=白
    winner: null | 0 | 1 | 2  // null=未结束, 0=平局
    
    // 历史记录
    moves: Array<{x, y, player, step, timestamp}>
    
    // 时间记录
    startTime: number | null
    endTime: number | null
    
    // 模式和难度
    gameMode: 'PvP' | 'PvE' | 'EvE' | 'VCF_PRACTICE'
    aiDifficulty: 'BEGINNER' | 'NORMAL' | 'HARD' | 'HELL'
    blackAIDifficulty: string  // EvE模式黑方AI难度
    whiteAIDifficulty: string  // EvE模式白方AI难度
    
    // AI配置
    aiAlgorithmMode: 'CLASSIC' | 'ADVANCED'
    aiDirections: Array<{dx, dy}>  // 4个搜索方向
    aiScoreTable: Object  // 评分表
}
```

#### 核心方法
```javascript
// === 游戏控制 ===
placePiece(x, y): {success, error?, gameOver?, winner?, ...}
  // 1. 验证坐标、位置、状态
  // 2. 检查禁手（仅黑棋）
  // 3. 更新棋盘和历史
  // 4. 判定胜负或平局
  // 5. 切换玩家
  // 返回操作结果

undoMove(): {success, steps}
  // 悔棋（PvP退1步，PvE/VCF退2步）

reset(): void
  // 重置游戏到初始状态

// === 规则判定 ===
checkWin(x, y, skipLog?): {isWin, winLine?, direction?}
  // 检查是否五连获胜
  // 遍历4个方向，统计连子数
  // 返回胜利信息

checkForbidden(x, y): {isForbidden, type?, details?}
  // 检查黑棋禁手（三三、四四、长连）
  // 临时落子，统计各方向棋型
  // 返回禁手信息

countOpenThrees(x, y, player): {total, directions}
  // 统计活三数量

countOpenFours(x, y, player): {total, directions}
  // 统计四的数量（活四+冲四）

checkLongLine(x, y, player): {hasLongLine, lines}
  // 检查是否六连及以上

// === AI算法 ===
getAIMove(difficulty?): {x, y} | null
  // AI落子入口，根据难度调用对应算法
  // BEGINNER: getAIMoveSimple()
  // NORMAL: getAIMoveNormal()
  // HARD: getAIMoveHard()
  // HELL: getAIMoveHell()

getAIMoveSimple(): {x, y}
  // 新手AI：随机+简单评分
  // 50%随机，50%基础评分

getAIMoveNormal(): {x, y}
  // 正常AI：防守优先+基础搜索
  // 1. 检查立即获胜
  // 2. 阻止对手获胜
  // 3. 基础评分选点

getAIMoveHard(): {x, y}
  // 困难AI：威胁检测+深度搜索
  // 1-3同NORMAL
  // 4. 关键威胁防守
  // 5. Alpha-Beta搜索(深度2)

getAIMoveHell(): {x, y}
  // 地狱AI：完整威胁空间
  // 1-3同HARD
  // 4. VCF搜索(进攻)
  // 5. VCF防守
  // 6. 关键威胁防守
  // 7. 活三防守
  // 8. Alpha-Beta搜索(深度3)

// === VCF算法 ===
findVCFMove(player, defenseMode, maxDepth): {x, y} | null
  // VCF(连续冲四)搜索
  // 找到所有冲四点，递归验证必胜序列

findAllFourMoves(player): Array<{x, y, score}>
  // 找到所有能形成四的位置

findOpenFourMove(player): {x, y} | null
  // 找到活四位置（必胜棋型）

findCriticalDefenseMove(opponent, defender): {x, y} | null
  // 找到关键防守点（双活三、活四等）

// === 数据管理 ===
exportData(): Object
  // 导出完整游戏数据（用于保存）
  // {version, gameInfo, boardState, moves, ...}

loadFromData(data): boolean
  // 从数据恢复游戏状态

getBoardState(): number[][]
  // 获取棋盘状态副本

getMoves(): Array<Move>
  // 获取历史记录

getGameInfo(): Object
  // 获取游戏信息（模式、时间、胜者等）
```

#### 评分系统
```javascript
aiScoreTable = {
    // 基础棋型分数
    five: 1000000,           // 五连（立即获胜）
    openFour: 160000,        // 活四 _●●●●_
    closedFour: 42000,       // 冲四 ●●●●_
    brokenFour: 55000,       // 断四 ●●_●●
    openThree: 12000,        // 活三 _●●●_
    closedThree: 2600,       // 睡三 ●●●__
    brokenThree: 6200,       // 断三 ●●_●_
    openTwo: 600,            // 活二 _●●_
    closedTwo: 150,          // 睡二 ●●___
    
    // 组合棋型分数（关键）
    doubleOpenFour: 420000,  // 双活四（必胜）
    doubleBrokenFour: 200000,// 双冲四
    doubleOpenThree: 36000,  // 双活三
    openFourSupport: 120000, // 活四+支援
    ...
}
```

---

### 3.2 board-renderer.js (SimpleBoardRenderer)

#### 职责
负责棋盘的Canvas渲染和用户交互处理。

#### 关键属性
```javascript
class SimpleBoardRenderer {
    canvas: HTMLCanvasElement
    ctx: CanvasRenderingContext2D
    
    // 棋盘配置
    boardSize: number = 15
    cellSize: number = 36
    padding: number = 30
    
    // 棋盘状态（同步自game-core）
    board: number[][]
    
    // 交互状态
    hoverX: number = -1
    hoverY: number = -1
    
    // 高亮状态
    forbiddenHighlight: {x, y, result, timestamp} | null
    hintHighlight: {x, y, timestamp} | null
    
    // 定时器
    forbiddenHighlightTimer: number | null
    hintHighlightTimer: number | null
}
```

#### 核心方法
```javascript
// === 初始化 ===
constructor(canvasId: string)
  // 1. 获取Canvas元素和2D上下文
  // 2. 设置Canvas尺寸（600x600）
  // 3. 初始化棋盘状态
  // 4. 绑定事件监听器
  // 5. 立即渲染

setupEventListeners(): void
  // 绑定click、mousemove、mouseleave事件

// === 渲染方法 ===
render(): void
  // 完整渲染流程：
  // 1. 清空画布
  // 2. 绘制背景色（木质色）
  // 3. 绘制网格线（15x15）
  // 4. 绘制星位点（5个）
  // 5. 绘制所有棋子
  // 6. 绘制悬停预览
  // 7. 绘制提示高亮
  // 8. 绘制禁手高亮

drawGrid(): void
  // 绘制15x15网格线

drawStarPoints(): void
  // 绘制5个星位点
  // 位置：(3,3), (3,11), (11,3), (11,11), (7,7)

drawPieces(): void
  // 遍历棋盘，绘制所有棋子
  // 最后一手标记红点

drawPiece(x, y, player, isLastMove): void
  // 绘制单个棋子
  // 黑棋：径向渐变 #4a4a4a→#1a1a1a
  // 白棋：径向渐变 #ffffff→#f8f8f8
  // 带阴影和高光效果

drawHoverPreview(): void
  // 悬停时绘制半透明预览棋子

drawHintHighlight(): void
  // 绘制提示高亮（绿色虚线圆+十字）

drawForbiddenHighlight(): void
  // 绘制禁手高亮（红色半透明圆+文字）

// === 交互处理 ===
placePiece(x, y): void
  // 处理落子逻辑：
  // 1. 判断是否VCF模式 → demo.handleVCFPracticeMove()
  // 2. 检查权限 demo.canPlacePiece()
  // 3. 调用 game.placePiece(x, y)
  // 4. 同步棋盘状态
  // 5. 重新渲染
  // 6. 通知UI层 demo.handleMoveResult()

highlightHintPosition(x, y, options): void
  // 高亮AI建议位置
  // 参数：duration（持续时间，默认5秒）

highlightForbiddenPosition(x, y, result): void
  // 高亮禁手位置
  // 1.8秒后自动消失

clearHintHighlight(redraw): void
  // 清除提示高亮

// === 工具方法 ===
getCurrentPlayer(): number
  // 获取当前玩家（从game或推断）

handleGameOver(result): void
  // 处理游戏结束，通知demo显示结果
```

#### 坐标转换逻辑
```javascript
// 像素坐标 → 棋盘坐标
gridX = Math.round((pixelX - padding) / cellSize)
gridY = Math.round((pixelY - padding) / cellSize)

// 棋盘坐标 → 像素坐标
screenX = padding + gridX * cellSize
screenY = padding + gridY * cellSize
```

---

### 3.3 demo.js (InterfaceDemo)

#### 职责
UI主控制器，协调所有模块，处理用户交互。

#### 关键属性
```javascript
class InterfaceDemo {
    // 状态
    currentPlayer: number = 1
    gameMode: string = 'PvE'
    moveCount: number = 0
    gameTime: number = 0
    
    // AI状态
    aiThinking: boolean = false
    aiTimer: number | null
    eveAutoPlay: boolean = false
    
    // 提示状态
    lastHintTime: number = 0
    hintCooldown: number = 3000
    
    // VCF练习状态
    practiceManager: VCFPracticeManager | null
    practiceState: {
        active: boolean
        currentPuzzle: Object | null
        stepIndex: number
        completed: boolean
    }
    
    // 功能模块
    gameSaveLoad: GameSaveLoad | null
    gameReplay: GameReplay | null
    
    // 模式列表
    availableModes: string[] = ['PvE', 'PvP', 'EvE']
}
```

#### 核心方法
```javascript
// === 初始化 ===
constructor()
  // 1. 检查依赖模块
  // 2. 初始化状态
  // 3. 调用 initializeDemo()
  // 4. 调用 setupEventListeners()
  // 5. 启动游戏计时器
  // 6. 初始化功能模块

setupEventListeners(): void
  // 绑定所有按钮和快捷键事件

// === 游戏控制 ===
startNewGame(): void
  // 1. 确认对话框（如有进行中的游戏）
  // 2. 调用 game.reset()
  // 3. 调用 boardRenderer.render()
  // 4. 重置UI状态
  // 5. EvE模式自动启动AI对战

toggleGameMode(): void
  // 循环切换模式：PvE → PvP → EvE → PvE
  // 1. 确认切换
  // 2. 设置新模式
  // 3. 重置游戏
  // 4. 更新UI显示

undoMove(): void
  // 1. 调用 game.undoMove()
  // 2. 同步渲染器
  // 3. 更新UI状态

showHint(): void
  // 1. 检查冷却时间
  // 2. 调用 game.getAIMove(hintStrength)
  // 3. 高亮显示建议位置
  // 4. 记录使用时间

// === 模式管理 ===
updateModeDisplay(): void
  // 根据模式显示/隐藏相应UI元素
  // - PvE: 显示单AI设置
  // - PvP: 隐藏AI设置
  // - EvE: 显示双AI设置，禁用悔棋/提示
  // - VCF: 显示VCF面板，隐藏其他

canPlacePiece(): boolean
  // 检查玩家是否可以落子
  // EvE模式: false
  // PvE模式且AI回合: false
  // 其他: true

// === AI管理 ===
simulateAIThinking(aiDifficulty, player): void
  // 1. 显示"AI思考中"动画
  // 2. 获取AI思考时间（根据难度）
  // 3. 延迟后调用 game.getAIMove()
  // 4. 调用 game.placePiece(x, y)
  // 5. 处理结果
  // 6. EvE模式继续下一步

startEveAutoPlay(): void
  // 启动EvE自动对战循环

getAIThinkingDuration(difficulty): number
  // 返回AI思考时间
  // BEGINNER: 500ms, NORMAL: 900ms
  // HARD: 1400ms, HELL: 1800ms

// === 事件处理 ===
handleMoveResult(result): void
  // 处理落子结果
  // 1. 更新UI状态（回合数、当前玩家）
  // 2. 检查游戏是否结束
  // 3. PvE模式触发AI落子
  // 4. EvE模式继续自动对战

handleVCFPracticeMove(x, y): void
  // VCF练习模式落子处理
  // 1. 调用 game.placePiece(x, y)
  // 2. 检查是否获胜或超步
  // 3. 触发AI防守
  // 4. 更新练习进度

handleForbiddenMove({x, y, result}): void
  // 处理禁手落子
  // 显示友好错误提示

// === VCF练习管理 ===
startVCFPractice(level): void
  // 1. 获取题目
  // 2. 加载初始棋盘
  // 3. 更新VCF面板
  // 4. 开始练习

restartVCFPuzzle(): void
  // 重新开始当前题目

executeVCFAIDefense(): void
  // 执行AI防守（地狱难度）
  // 400ms延迟后落子

// === UI更新 ===
updateGameStatus(): void
  // 更新游戏状态显示
  // 模式、难度、回合数

updateCurrentPlayer(): void
  // 更新当前玩家显示
  // 棋子图标和文字

updateHintMessage(message, type): void
  // 更新提示信息

showGameResult(result): void
  // 显示游戏结果弹窗
  // 获胜方、用时、统计

// === 弹窗管理 ===
showModal(modalId): void
hideModal(modalId): void
hideAllModals(): void

showSettings(): void
saveSettings(): void
resetSettings(): void

showHelp(): void
```

---

### 3.4 其他核心模块（简述）

#### vcf-practice.js (VCFPracticeManager)
```javascript
class VCFPracticeManager {
    puzzles: Array<Puzzle> = []  // 40道题库
    currentPuzzle: Puzzle | null
    currentLevel: number = 1
    progress: Object  // 进度数据
    
    initializePuzzles(): Array<Puzzle>
      // 生成40道题库（4个等级，每级10题）
    
    getPuzzle(level, index): Puzzle
      // 获取指定题目
    
    loadProgress(): Object
      // 从LocalStorage加载进度
    
    saveProgress(progress): void
      // 保存进度到LocalStorage
    
    updateProgress(puzzleId, time, won): void
      // 更新完成记录和最佳时间
}
```

#### ai-advanced.js (AdvancedAI)
```javascript
class AdvancedAI {
    game: GomokuGame
    openingBook: Object  // 开局库
    scoreTable: Object   // 改进的评分表
    patterns: Object     // 棋型正则表达式
    
    getMove(difficulty): {x, y}
      // 高级AI算法入口
      // 1. 开局库查询
      // 2. VCF搜索
      // 3. 威胁序列搜索
      // 4. 迭代加深搜索
    
    searchVCF(player, depth, maxDepth): {x, y} | null
      // VCF搜索（递归）
    
    searchThreatSequence(aiPlayer, opponent): {x, y, score} | null
      // 威胁序列搜索
    
    iterativeDeepeningSearch(aiPlayer, opponent, maxDepth): {x, y}
      // 迭代加深搜索
    
    alphaBetaSearch(aiPlayer, opponent, depth, alpha, beta, isMaximizing): [score, move]
      // Alpha-Beta剪枝搜索
}
```

#### game-save-load.js (GameSaveLoad)
```javascript
class GameSaveLoad {
    currentGameData: Object | null
    autoSaveEnabled: boolean = true
    autoSaveInterval: number | null
    
    saveGame(): void
      // 导出游戏数据为JSON文件
    
    loadGame(): void
      // 触发文件选择器
    
    handleFileLoad(event): void
      // 读取JSON文件，解析并加载
    
    loadGameFromData(gameData): void
      // 从数据恢复游戏状态
    
    validateGameData(gameData): void
      // 验证数据格式和版本兼容性
    
    startAutoSave(): void
      // 启动自动保存（每30秒）
}
```

#### game-replay.js (GameReplay)
```javascript
class GameReplay {
    replayData: Object | null
    currentStep: number = 0
    totalSteps: number = 0
    isPlaying: boolean = false
    playSpeed: number = 1
    replayEngine: GomokuGame  // 独立引擎
    
    startReplay(): void
      // 启动回放模式
    
    seekToStep(step): void
      // 跳转到指定步骤
    
    rebuildBoardToStep(targetStep): void
      // 重建棋盘到目标步
    
    startPlaying(speed): void
      // 自动播放
    
    pausePlaying(): void
      // 暂停播放
}
```

#### utils.js (GameUtils)
```javascript
const GameUtils = {
    showMessage(message, type, duration): void
      // 显示提示消息
    
    formatTime(timestamp): string
      // 格式化时间为 HH:MM:SS
    
    formatDuration(seconds): string
      // 格式化时长为 MM:SS
    
    generateFileName(prefix, extension): string
      // 生成带时间戳的文件名
    
    deepClone(obj): any
      // 深度克隆对象
    
    throttle(func, delay): Function
    debounce(func, delay): Function
    
    isValidPosition(x, y, size): boolean
      // 验证坐标有效性
    
    positionToNotation(x, y): string
      // 坐标转换为字母数字表示（如"H8"）
    
    saveToLocalStorage(key, data): boolean
    loadFromLocalStorage(key): any
    
    downloadAsJSON(data, filename): boolean
      // 下载数据为JSON文件
}
```

---

## 4. 数据流设计

### 4.1 玩家落子流程（PvE模式）

```
用户点击Canvas
    ↓
[board-renderer.js]
SimpleBoardRenderer.canvas.click事件
    ↓
计算棋盘坐标: gridX, gridY
    ↓
SimpleBoardRenderer.placePiece(gridX, gridY)
    ↓
检查模式: if (gameMode === 'VCF_PRACTICE')
    YES → demo.handleVCFPracticeMove(x, y) → 结束
    NO  ↓
检查权限: demo.canPlacePiece()
    false → 显示错误提示 → 结束
    true  ↓
调用核心引擎: game.placePiece(x, y)
    ↓
[game-core.js]
GomokuGame.placePiece(x, y)
    ├─ 验证坐标有效性
    ├─ 验证位置未被占用
    ├─ 验证游戏未结束
    ├─ [黑棋] 检查禁手 checkForbidden(x, y)
    │   ├─ 临时落子 board[y][x] = 1
    │   ├─ 统计活三: countOpenThrees()
    │   ├─ 统计四: countOpenFours()
    │   ├─ 检查长连: checkLongLine()
    │   ├─ 撤销落子 board[y][x] = 0
    │   └─ 返回禁手结果
    │   └─ if (isForbidden) → 返回错误 → 结束
    ├─ 执行落子: board[y][x] = currentPlayer
    ├─ 记录历史: moves.push({x, y, player, step, timestamp})
    ├─ 判定胜负: checkWin(x, y)
    │   ├─ 遍历4个方向
    │   ├─ 统计连子数 getLine(x, y, dx, dy, player)
    │   ├─ if (count >= 5) → 胜利
    │   └─ 返回胜利信息
    ├─ 检查平局: if (moves.length === 225) → 平局
    ├─ 切换玩家: currentPlayer = (currentPlayer === 1) ? 2 : 1
    └─ 返回结果 {success: true, gameOver?, winner?}
    ↓
[board-renderer.js]
SimpleBoardRenderer.placePiece() 继续
    ├─ 同步棋盘状态: board = game.getBoardState()
    ├─ 清除提示高亮: clearHintHighlight()
    ├─ 重新渲染: render()
    ├─ 通知UI层: demo.handleMoveResult({x, y, player, result})
    └─ if (result.gameOver) → handleGameOver(result)
    ↓
[demo.js]
InterfaceDemo.handleMoveResult(data)
    ├─ 更新回合数显示: moveCount++
    ├─ 更新当前玩家显示: updateCurrentPlayer()
    ├─ 更新游戏状态显示: updateGameStatus()
    ├─ if (result.gameOver) → 结束
    ├─ if (gameMode === 'PvE' && currentPlayer === 2)
    │   └─ 触发AI落子: simulateAIThinking()
    └─ 结束
    ↓
[demo.js]
InterfaceDemo.simulateAIThinking()
    ├─ 显示"AI思考中"动画
    ├─ 获取思考时间: getAIThinkingDuration(aiDifficulty)
    ├─ 延迟执行: setTimeout(() => {
    │   ├─ 调用AI算法: aiMove = game.getAIMove(aiDifficulty)
    │   ├─ 调用核心引擎: result = game.placePiece(aiMove.x, aiMove.y)
    │   ├─ 同步渲染器: boardRenderer.board = game.getBoardState()
    │   ├─ 重新渲染: boardRenderer.render()
    │   ├─ 隐藏思考动画
    │   ├─ 处理结果: handleMoveResult({x, y, player:2, result})
    │   └─ if (result.gameOver) → 显示结果弹窗
    └─ }, thinkingDuration)
```

### 4.2 AI决策流程（地狱难度）

```
demo.simulateAIThinking(aiDifficulty='HELL')
    ↓
调用: game.getAIMove('HELL')
    ↓
[game-core.js]
GomokuGame.getAIMove('HELL')
    ↓
调用: getAIMoveHell()
    ↓
[步骤1] 检查立即获胜
    findWinningMove(aiPlayer)
    ├─ 获取候选点: getCandidateMoves(2, 50)
    ├─ 遍历每个候选点:
    │   ├─ 临时落子: board[y][x] = aiPlayer
    │   ├─ 判定五连: checkWin(x, y, true)
    │   ├─ 撤销落子: board[y][x] = 0
    │   └─ if (isWin && !isForbidden) → 返回该点
    └─ 未找到 → 继续下一步
    ↓
[步骤2] 阻止对手获胜
    findWinningMove(opponent)
    └─ 逻辑同步骤1，返回对手获胜点作为防守点
    └─ if (found) → 返回该点
    ↓
[步骤3] VCF搜索（进攻）
    findVCFMove(aiPlayer, false, maxDepth=6)
    ├─ 找到所有冲四点: findAllFourMoves(aiPlayer)
    ├─ 对每个冲四点:
    │   ├─ 临时落子: board[y][x] = aiPlayer
    │   ├─ 检查立即获胜: checkWin(x, y)
    │   ├─ if (获胜) → 返回该点
    │   ├─ 获取对手防守点: findAllFourMoves(opponent)相邻位置
    │   ├─ 对每个防守点:
    │   │   ├─ 临时落子: board[y][x] = opponent
    │   │   ├─ 递归搜索: findVCFMove(aiPlayer, false, depth+1)
    │   │   ├─ 撤销落子: board[y][x] = 0
    │   │   └─ if (!递归成功) → 该冲四点无效
    │   └─ 撤销落子: board[y][x] = 0
    └─ 未找到必胜VCF → 继续下一步
    ↓
[步骤4] VCF防守
    findVCFDefenseMove(opponent)
    ├─ 获取候选点: getCandidateMoves(2, 20)
    ├─ 对每个候选点:
    │   ├─ 临时落子: board[y][x] = opponent
    │   ├─ 检查对手VCF: findVCFMove(opponent, false, 6)
    │   ├─ 撤销落子: board[y][x] = 0
    │   └─ if (对手有VCF) → 返回该防守点
    └─ 未找到VCF威胁 → 继续下一步
    ↓
[步骤5] 关键威胁防守
    findCriticalDefenseMove(opponent, aiPlayer)
    ├─ 检查对手双活三: countOpenThrees(每个候选点)
    ├─ 检查对手活四: findOpenFourMove(opponent)
    ├─ 检查对手双冲四: findAllFourMoves(opponent)
    └─ if (找到关键威胁) → 返回防守点
    ↓
[步骤6] 活三防守
    findOpenThreeDefense(opponent)
    ├─ 找到对手所有活三位置
    ├─ 对每个活三:
    │   └─ 找到最优防守点（阻断或反威胁）
    └─ 返回最高评分防守点
    ↓
[步骤7] Alpha-Beta搜索
    alphaBetaMinimax(depth=3, alpha=-∞, beta=+∞, true, aiPlayer)
    ├─ 生成候选移动: getCandidateMoves(2, 30)
    ├─ 对每个候选移动:
    │   ├─ 临时落子: board[y][x] = aiPlayer
    │   ├─ 递归搜索: alphaBetaMinimax(depth-1, alpha, beta, false, opponent)
    │   ├─ 撤销落子: board[y][x] = 0
    │   ├─ 更新alpha: alpha = max(alpha, score)
    │   └─ 剪枝: if (beta <= alpha) → break
    └─ 返回最高评分移动
    ↓
[步骤8] 降级策略
    findAnyValidMove()
    └─ 返回任意合法点（中心优先）
    ↓
返回: {x, y}
    ↓
[demo.js]
执行AI落子: game.placePiece(aiMove.x, aiMove.y)
    ↓
... [回到玩家落子流程的核心引擎部分]
```

### 4.3 游戏保存/加载流程

#### 保存流程
```
用户点击"保存棋局"按钮
    ↓
[demo.js] 通过事件委托
    ↓
[game-save-load.js]
GameSaveLoad.saveGame()
    ├─ 调用: getCurrentGameData()
    │   ├─ 调用: game.exportData()
    │   │   └─ 返回: {version, gameInfo, boardState, moves, ...}
    │   ├─ 调用: game.getGameInfo()
    │   ├─ 组装完整数据: gameData
    │   └─ 返回: gameData
    ├─ 检查: if (!gameData || moves.length === 0)
    │   └─ 显示提示："当前没有可保存的棋局" → 结束
    ├─ 生成文件名: generateFileName(gameData)
    │   └─ 返回: "五子棋_PvE_25步_2025-01-15_14-30-45.json"
    ├─ 调用: GameUtils.downloadAsJSON(gameData, fileName)
    │   ├─ JSON序列化: JSON.stringify(gameData, null, 2)
    │   ├─ 创建Blob: new Blob([jsonData], {type: 'application/json'})
    │   ├─ 创建下载链接: URL.createObjectURL(blob)
    │   ├─ 创建<a>元素并点击触发下载
    │   └─ 清理: URL.revokeObjectURL(url)
    └─ 显示提示: "棋局保存成功"
```

#### 加载流程
```
用户点击"加载棋局"按钮
    ↓
[game-save-load.js]
GameSaveLoad.loadGame()
    ├─ 触发文件选择: document.getElementById('load-game-input').click()
    └─ 等待用户选择文件
    ↓
用户选择.json文件
    ↓
[game-save-load.js]
GameSaveLoad.handleFileLoad(event)
    ├─ 获取文件: event.target.files[0]
    ├─ 验证扩展名: file.name.endsWith('.json')
    ├─ 创建FileReader: new FileReader()
    ├─ 读取文件: reader.readAsText(file)
    └─ 文件读取完成事件: reader.onload
    ↓
    ├─ JSON解析: gameData = JSON.parse(e.target.result)
    ├─ 调用: loadGameFromData(gameData)
    │   ↓
    │   ├─ 验证数据: validateGameData(gameData)
    │   │   ├─ 检查必需字段: version, gameInfo, boardState, moves
    │   │   ├─ 验证棋盘格式: boardState.length === 15
    │   │   ├─ 验证moves格式: Array.isArray(moves)
    │   │   ├─ 验证版本兼容: supportedVersions.includes(version)
    │   │   └─ if (invalid) → throw Error
    │   ├─ 确认覆盖: if (hasCurrentGame()) → confirm对话框
    │   ├─ 重置游戏: game.reset()
    │   ├─ 恢复状态: restoreGameState(gameData)
    │   │   ├─ 调用: game.loadFromData(gameData)
    │   │   │   ├─ 恢复棋盘: board = gameData.boardState
    │   │   │   ├─ 恢复历史: moves = gameData.moves
    │   │   │   ├─ 恢复玩家: currentPlayer = gameData.currentPlayer
    │   │   │   ├─ 恢复时间: startTime = gameData.gameInfo.startTime
    │   │   │   └─ 返回: true
    │   │   ├─ 同步渲染器: boardRenderer.board = game.getBoardState()
    │   │   ├─ 重新渲染: boardRenderer.render()
    │   │   ├─ 恢复设置: restoreSettings(gameData.settings)
    │   │   └─ 更新UI: restoreUI(gameData)
    │   │       ├─ 更新模式显示
    │   │       ├─ 更新当前玩家显示
    │   │       ├─ 更新回合数显示
    │   │       ├─ 更新用时显示
    │   │       └─ 同步demo内部状态
    │   ├─ 启用回放按钮: replayBtn.disabled = false
    │   └─ 显示提示: "棋局加载成功 (25步)"
    └─ 结束
```

---

## 5. 关键算法详解

### 5.1 禁手检测算法

#### 活三检测
```javascript
function countOpenThreesInLine(lineSignature) {
    // lineSignature示例："000011100" (位置4落子形成活三)
    // 0=空, 1=玩家棋子, 2=对手或边界
    
    const patterns = [
        '01110',    // 连三型活三 _●●●_
        '011010',   // 连二跳一 _●●_●_
        '010110'    // 跳一连二 _●_●●_
    ];
    
    for (const pattern of patterns) {
        let index = signature.indexOf(pattern);
        if (index === -1) continue;
        
        while (index !== -1) {
            // 检查两端是否有立即延伸的棋子（避免将活四误判为活三）
            const left = signature[index - 1];
            const right = signature[index + pattern.length];
            
            // 活三要求：两端无立即延伸
            if (left !== '1' && right !== '1') {
                return 1; // 找到活三
            }
            
            index = signature.indexOf(pattern, index + 1);
        }
    }
    
    return 0;
}
```

#### 四四禁手检测
```javascript
function countOpenFoursInLine(lineSignature) {
    // 活四：两端都能成五
    const activeFourPatterns = ['011110'];
    
    // 冲四：只有一端能成五
    const rushFourPatterns = [
        '11110',   // 一端封闭
        '01111',   // 另一端封闭
        '11011',   // 中间断开
        '11101',   // 中间断开
        '10111'    // 中间断开
    ];
    
    let count = 0;
    
    // 检查活四
    for (const pattern of activeFourPatterns) {
        if (signature.includes(pattern)) count++;
    }
    
    // 检查冲四
    for (const pattern of rushFourPatterns) {
        if (signature.includes(pattern)) count++;
    }
    
    return count;
}
```

### 5.2 VCF搜索算法（连续冲四）

```javascript
function findVCFMove(player, defenseMode = false, maxDepth = 6) {
    const opponent = player === 1 ? 2 : 1;
    
    // 递归终止条件
    if (maxDepth <= 0) return null;
    
    // 找到所有冲四点
    const fourMoves = findAllFourMoves(player);
    if (fourMoves.length === 0) return null;
    
    // 遍历每个冲四点
    for (const fourMove of fourMoves) {
        // 临时落子
        board[fourMove.y][fourMove.x] = player;
        
        // 检查是否立即获胜
        if (checkWin(fourMove.x, fourMove.y, true).isWin) {
            board[fourMove.y][fourMove.x] = 0;
            return fourMove; // 找到立即获胜的冲四
        }
        
        // 获取对手所有防守点
        const defenseMoves = findDefenseMoves(fourMove);
        let allDefensesFail = true;
        
        // 检查对手每个防守是否都能被破解
        for (const defense of defenseMoves) {
            board[defense.y][defense.x] = opponent;
            
            // 递归搜索：对手防守后，我方能否继续VCF
            const nextVCF = findVCFMove(player, false, maxDepth - 1);
            
            board[defense.y][defense.x] = 0;
            
            if (!nextVCF) {
                // 对手有一个防守点能阻止VCF
                allDefensesFail = false;
                break;
            }
        }
        
        board[fourMove.y][fourMove.x] = 0;
        
        // 如果对手所有防守都失败，则当前冲四是VCF必胜点
        if (allDefensesFail && defenseMoves.length > 0) {
            return fourMove;
        }
    }
    
    return null; // 未找到VCF
}
```

### 5.3 Alpha-Beta剪枝搜索

```javascript
function alphaBetaMinimax(depth, alpha, beta, isMaximizing, player) {
    // 终止条件
    if (depth === 0 || gameStatus === 'finished') {
        return [evaluateBoard(player), null];
    }
    
    const moves = getCandidateMoves(2, 30);
    let bestMove = null;
    
    if (isMaximizing) {
        let maxEval = -Infinity;
        
        for (const move of moves) {
            // 模拟落子
            board[move.y][move.x] = player;
            
            // 递归搜索
            const [evalScore] = alphaBetaMinimax(
                depth - 1,
                alpha,
                beta,
                false,
                opponent
            );
            
            // 撤销落子
            board[move.y][move.x] = 0;
            
            // 更新最大值
            if (evalScore > maxEval) {
                maxEval = evalScore;
                bestMove = move;
            }
            
            // 更新alpha
            alpha = Math.max(alpha, evalScore);
            
            // Beta剪枝
            if (beta <= alpha) {
                break; // 剪枝，不再搜索后续分支
            }
        }
        
        return [maxEval, bestMove];
    } else {
        let minEval = Infinity;
        
        for (const move of moves) {
            board[move.y][move.x] = opponent;
            const [evalScore] = alphaBetaMinimax(
                depth - 1,
                alpha,
                beta,
                true,
                player
            );
            board[move.y][move.x] = 0;
            
            if (evalScore < minEval) {
                minEval = evalScore;
                bestMove = move;
            }
            
            beta = Math.min(beta, evalScore);
            
            // Alpha剪枝
            if (beta <= alpha) {
                break;
            }
        }
        
        return [minEval, bestMove];
    }
}
```

---

## 6. 模块导出机制

### 6.1 导出模式
所有模块使用统一的导出模式：

```javascript
// === 模块文件结构 ===

// 1. 类定义
class ModuleName {
    constructor() {
        // 初始化
    }
    
    // 方法定义
    method1() {}
    method2() {}
}

// 2. 模块元信息
const MODULE_INFO = {
    name: 'ModuleName',
    version: '1.2.0',
    author: '项目团队',
    dependencies: ['GameUtils', 'OtherModule']
};

ModuleName.__moduleInfo = MODULE_INFO;

// 3. 浏览器环境导出
if (typeof window !== 'undefined') {
    window.ModuleName = ModuleName;
    
    // 4. 触发模块加载事件
    if (typeof window.dispatchEvent === 'function') {
        window.dispatchEvent(new CustomEvent('moduleLoaded', {
            detail: MODULE_INFO
        }));
    }
}

// 5. CommonJS导出（可选，用于测试环境）
if (typeof module !== 'undefined' && module.exports) {
    module.exports = ModuleName;
}
```

### 6.2 依赖检查工具

```javascript
// 在demo.js中使用
const ModuleDependencyChecker = {
    checkDependencies(requiredModules) {
        const missing = [];
        const loaded = [];
        
        requiredModules.forEach(moduleName => {
            if (typeof window[moduleName] === 'undefined') {
                missing.push(moduleName);
            } else {
                loaded.push({
                    name: moduleName,
                    info: window[moduleName].__moduleInfo || null
                });
            }
        });
        
        return {
            success: missing.length === 0,
            missing,
            loaded,
            message: missing.length > 0 
                ? `缺少必需模块: ${missing.join(', ')}` 
                : '所有依赖模块已加载'
        };
    }
};

// 使用示例
const dependencyCheck = ModuleDependencyChecker.checkDependencies([
    'GameUtils',
    'GomokuGame',
    'SimpleBoardRenderer'
]);

if (!dependencyCheck.success) {
    throw new Error(dependencyCheck.message);
}
```

### 6.3 加载顺序（index.html）

```html
<!-- 1. 工具模块（无依赖） -->
<script src="js/utils.js"></script>

<!-- 2. 高级AI（依赖utils，可选） -->
<script src="js/ai-advanced.js"></script>

<!-- 3. 游戏核心（依赖utils和ai-advanced） -->
<script src="js/game-core.js"></script>

<!-- 4. 渲染器（依赖game-core） -->
<script src="js/board-renderer.js"></script>

<!-- 5. VCF管理器（依赖game-core） -->
<script src="js/vcf-practice.js"></script>

<!-- 6. 存档模块（依赖game-core和utils） -->
<script src="js/game-save-load.js"></script>

<!-- 7. 回放模块（依赖game-core和utils） -->
<script src="js/game-replay.js"></script>

<!-- 8. UI主控（依赖所有模块） -->
<script src="js/demo.js"></script>
```

---

## 7. 性能优化策略

### 7.1 Canvas渲染优化
```javascript
// 1. 避免全局重绘
// - 仅在状态变化时调用render()
// - 使用脏区域标记

// 2. 使用离屏Canvas（可选）
const offscreenCanvas = document.createElement('canvas');
// 先在离屏Canvas绘制，再一次性复制到显示Canvas

// 3. 减少绘制调用
// - 合并相同样式的绘制操作
// - 使用beginPath()和closePath()正确管理路径
```

### 7.2 AI算法优化
```javascript
// 1. 候选移动生成优化
getCandidateMoves(range, limit) {
    // 仅搜索已有棋子周围range格范围内的空位
    // 限制候选数量为limit个
    // 按启发式评分排序，优先搜索高价值位置
}

// 2. Alpha-Beta剪枝
// - 移动排序：优先搜索可能性大的移动
// - 历史启发：记录上次搜索的好移动
// - 杀手移动：记录导致剪枝的移动

// 3. 置换表（未实现，可扩展）
// - 缓存已评估过的局面
// - 避免重复计算
```

### 7.3 DOM操作优化
```javascript
// 1. 批量更新
// - 使用DocumentFragment
// - 减少reflow和repaint

// 2. 事件委托
// - 在父元素上监听，通过event.target判断

// 3. 防抖和节流
// - 使用GameUtils.debounce()和throttle()
// - 限制频繁触发的事件（如mousemove）
```

---

## 8. 安全性设计

### 8.1 输入验证
```javascript
// 所有用户输入都需验证
function placePiece(x, y) {
    // 1. 类型检查
    if (typeof x !== 'number' || typeof y !== 'number') {
        return {success: false, error: '无效的坐标类型'};
    }
    
    // 2. 范围检查
    if (!isValidPosition(x, y)) {
        return {success: false, error: '坐标超出范围'};
    }
    
    // 3. 状态检查
    if (board[y][x] !== 0) {
        return {success: false, error: '该位置已有棋子'};
    }
    
    // 4. 权限检查
    if (!canPlacePiece()) {
        return {success: false, error: '当前无法落子'};
    }
    
    // ... 继续处理
}
```

### 8.2 数据验证
```javascript
// 加载外部数据时严格验证
function validateGameData(data) {
    // 1. 结构验证
    const requiredFields = ['version', 'gameInfo', 'boardState', 'moves'];
    for (const field of requiredFields) {
        if (!(field in data)) {
            throw new Error(`缺少必需字段: ${field}`);
        }
    }
    
    // 2. 类型验证
    if (!Array.isArray(data.boardState) || data.boardState.length !== 15) {
        throw new Error('无效的棋盘数据格式');
    }
    
    // 3. 版本兼容性验证
    const supportedVersions = ['1.0.0', '1.0.1', '1.1.0', '1.2.0'];
    if (!supportedVersions.includes(data.version)) {
        throw new Error(`不兼容的版本: ${data.version}`);
    }
    
    // 4. 数据范围验证
    data.boardState.forEach((row, y) => {
        row.forEach((cell, x) => {
            if (![0, 1, 2].includes(cell)) {
                throw new Error(`无效的棋子值: board[${y}][${x}] = ${cell}`);
            }
        });
    });
}
```

### 8.3 XSS防护
```javascript
// 1. 避免使用innerHTML
// 使用textContent代替

// 错误示例
element.innerHTML = userInput; // 危险！

// 正确示例
element.textContent = userInput; // 安全

// 2. 验证和转义
function escapeHtml(text) {
    const map = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, m => map[m]);
}
```

---

## 9. 可扩展性设计

### 9.1 新增游戏模式
```javascript
// 1. 在game-core.js添加模式支持
setGameMode(mode) {
    const validModes = ['PvP', 'PvE', 'EvE', 'VCF_PRACTICE', 'NEW_MODE'];
    if (validModes.includes(mode)) {
        this.gameMode = mode;
    }
}

// 2. 在demo.js添加UI逻辑
if (this.gameMode === 'NEW_MODE') {
    // 特殊处理逻辑
}

// 3. 在board-renderer.js添加渲染逻辑
if (window.demo && window.demo.gameMode === 'NEW_MODE') {
    // 特殊渲染逻辑
}
```

### 9.2 新增AI难度
```javascript
// 1. 在game-core.js添加难度方法
getAIMove(difficulty) {
    switch(difficulty) {
        case 'BEGINNER':
            return this.getAIMoveSimple();
        case 'NORMAL':
            return this.getAIMoveNormal();
        case 'HARD':
            return this.getAIMoveHard();
        case 'HELL':
            return this.getAIMoveHell();
        case 'NEW_DIFFICULTY':
            return this.getAIMoveNew(); // 新增方法
        default:
            return this.getAIMoveNormal();
    }
}

// 2. 实现新难度算法
getAIMoveNew() {
    // 新算法实现
}

// 3. 在index.html添加选项
<select id="ai-difficulty">
    <option value="BEGINNER">新手</option>
    <option value="NORMAL">正常</option>
    <option value="HARD">困难</option>
    <option value="HELL">地狱</option>
    <option value="NEW_DIFFICULTY">新难度</option>
</select>
```

### 9.3 新增辅助功能模块
```javascript
// 1. 创建新模块文件 js/new-feature.js
class NewFeature {
    constructor() {
        // 初始化
    }
    
    // 功能方法
}

// 2. 添加模块信息
NewFeature.__moduleInfo = {
    name: 'NewFeature',
    version: '1.0.0',
    dependencies: ['GameUtils', 'GomokuGame']
};

// 3. 导出模块
if (typeof window !== 'undefined') {
    window.NewFeature = NewFeature;
}

// 4. 在index.html中加载
<script src="js/new-feature.js"></script>

// 5. 在demo.js中使用
constructor() {
    // 检查可选模块
    if (typeof window.NewFeature !== 'undefined') {
        this.newFeature = new NewFeature();
    }
}
```

---

**文档版本**: v1.0  
**最后更新**: 2025-01  
**下一篇**: [03_游戏规则与AI算法要点.md](./03_游戏规则与AI算法要点.md)
