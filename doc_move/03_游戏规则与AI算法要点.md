# 03 - 游戏规则与AI算法要点

> **目的**: 将五子棋规则、禁手判定、AI策略、VCF练习逻辑系统化，供AI复刻游戏核心逻辑

---

## 1. 棋盘与坐标体系

### 1.1 棋盘规格
- 尺寸: 15 × 15
- 坐标范围: x=0~14, y=0~14
- 数据结构: 二维数组 `board[y][x]`
- 初始状态: 全部置0 (0=空, 1=黑, 2=白)

```javascript
// 初始化棋盘
this.board = Array(15).fill().map(() => Array(15).fill(0));
```

### 1.2 坐标转换

| 类型 | 公式 |
|------|------|
| 鼠标坐标 → 棋盘坐标 | `gridX = Math.round((mouseX - padding) / cellSize)` |
| 棋盘坐标 → Canvas坐标 | `canvasX = padding + gridX * cellSize` |
| 坐标字符串 | `GameUtils.positionToNotation(x,y)` → `H8` |

---

## 2. 基本规则

### 2.1 落子流程

```javascript
placePiece(x, y) {
    // 1. 边界检查
    if (!isValidPosition(x, y)) return error('INVALID_POSITION');

    // 2. 位置空闲检查
    if (board[y][x] !== 0) return error('POSITION_OCCUPIED');

    // 3. 游戏状态检查
    if (gameStatus === 'finished') return error('GAME_FINISHED');

    // 4. 禁手检测（仅黑棋）
    if (currentPlayer === BLACK) {
        const forbidden = checkForbidden(x, y);
        if (forbidden.isForbidden) return error('FORBIDDEN_MOVE', forbidden.type);
    }

    // 5. 落子 & 记录
    board[y][x] = currentPlayer;
    moves.push({x, y, player: currentPlayer, timestamp: Date.now(), step: moves.length + 1});

    // 6. 状态更新
    if (gameStatus === 'ready') startTime = Date.now();

    // 7. 胜负判定
    const winResult = checkWin(x, y);
    if (winResult.isWin) return finishGame(currentPlayer, winResult);

    // 8. 平局判定
    if (moves.length === 225) return finishDraw();

    // 9. 切换玩家
    currentPlayer = (currentPlayer === 1 ? 2 : 1);
    return { success: true, gameOver: false, nextPlayer: currentPlayer };
}
```

### 2.2 胜负判定

```javascript
checkWin(x, y) {
    const player = board[y][x];
    const directions = [
        { dx: 1, dy: 0 },  // 横向
        { dx: 0, dy: 1 },  // 纵向
        { dx: 1, dy: 1 },  // 主对角 ↘
        { dx: 1, dy: -1 }  // 副对角 ↗
    ];

    for (const dir of directions) {
        const line = getLine(x, y, dir.dx, dir.dy, player);
        if (line.length >= 5) {
            return { isWin: true, winLine: line, direction: dir };
        }
    }
    return { isWin: false };
}
```

`getLine()` 会沿指定方向统计连续同色棋子，并返回坐标列表，用于高亮胜利连线。

---

## 3. 禁手判定 (仅黑棋)

### 3.1 检测流程

```javascript
checkForbidden(x, y) {
    if (currentPlayer !== BLACK) return { isForbidden: false };

    // 临时落子
goBoard[y][x] = BLACK;

    // 1. 长连 (优先级最高)
    const longLine = checkLongLine(x, y, BLACK);
    if (longLine.hasLongLine) return forbidden('长连禁手', longLine);

    // 2. 统计活三/活四
    const openThrees = countOpenThrees(x, y, BLACK);
    const openFours  = countOpenFours(x, y, BLACK);

    // 恢复
    board[y][x] = EMPTY;

    if (openFours.total >= 2) return forbidden('四四禁手', {openThrees, openFours});
    if (openThrees.total >= 2) return forbidden('三三禁手', {openThrees, openFours});

    return { isForbidden: false, details: {openThrees, openFours, longLine} };
}
```

### 3.2 长连检测

```javascript
checkLongLine(x, y, player) {
    for (const dir of directions) {
        const line = getLine(x, y, dir.dx, dir.dy, player);
        if (line.length >= 6) {
            return { hasLongLine: true, direction: dir, line };
        }
    }
    return { hasLongLine: false };
}
```

### 3.3 活三/活四识别

使用“线性签名”方法，将指定方向的9个格子编码成字符串：

```
编码规则: 0=空, 1=己方, 2=对方, 3=边界
示例: "30111003" 表示 [边界][空][己][己][己][空][边界]
```

#### 活三模式
```
01110    // 连三
011010   // 中间空一格
010110   // 左右不对称跳三
```

#### 活四模式
```
011110   // 活四
01111    // 冲四 (右端堵)
11110    // 冲四 (左端堵)
11011    // 中断冲四
```

检测算法：
```javascript
countOpenThreesInLine(signature) {
    const patterns = ['01110', '011010', '010110'];
    const normalized = signature.replace(/3/g, '2');

    for (const pattern of patterns) {
        let index = normalized.indexOf(pattern);
        while (index !== -1) {
            const left  = normalized[index - 1];
            const right = normalized[index + pattern.length];
            const hasLeftExtension  = left === '1';
            const hasRightExtension = right === '1';
            if (!hasLeftExtension && !hasRightExtension) return 1;
            index = normalized.indexOf(pattern, index + 1);
        }
    }
    return 0;
}
```

---

## 4. AI算法体系

### 4.1 难度分级

| 难度 | 深度 | 算法 | 特性 |
|------|------|------|------|
| BEGINNER | 2层 | 简单评分 | 进攻偏好，易犯错 |
| NORMAL   | 3层 | Minimax + Alpha-Beta | 攻守平衡，识别活三冲四 |
| HARD     | 4层 | 迭代加深 + 威胁分析 | 识别双威胁，寻找必胜序列 |
| HELL     | 5层 | VCF搜索 + 完整威胁分析 | 开局库，VCF攻防，接近完美 |

### 4.2 AI决策流程（HELL）

```javascript
getMove('HELL') {
    // 1. 开局库 (moves <= 2)
    const openingMove = getOpeningMove();
    if (openingMove) return openingMove;

    // 2. 立即获胜
    const winMove = findWinningMove(aiPlayer);
    if (winMove) return winMove;

    // 3. 阻挡对手获胜
    const blockMove = findWinningMove(opponent);
    if (blockMove) return blockMove;

    // 4. VCF攻防
    const vcfAttack = searchVCF(aiPlayer);
    if (vcfAttack) return vcfAttack;

    const vcfDefense = searchVCFDefense(opponent);
    if (vcfDefense) return vcfDefense;

    // 5. 威胁序列
    const threatMove = searchThreatSequence(aiPlayer, opponent);
    if (threatMove && threatMove.score > 100000) return threatMove;

    // 6. 深度搜索
    return iterativeDeepeningSearch(aiPlayer, opponent, depth=5);
}
```

### 4.3 候选点生成

```javascript
getCandidateMoves(range = 2, limit = 30) {
    const candidates = [];
    for (let y = 0; y < 15; y++) {
        for (let x = 0; x < 15; x++) {
            if (board[y][x] !== 0) continue;
            if (hasNeighbor(x, y, range)) {
                const score = evaluatePosition(x, y, currentPlayer);
                candidates.push({x, y, score});
            }
        }
    }
    candidates.sort((a, b) => b.score - a.score);
    return candidates.slice(0, limit);
}
```

**邻居判断**: 至少一个邻居在 `range` 范围内有棋子，以减少搜索空间。

### 4.4 评估函数 (示例)

```javascript
evaluatePosition(x, y, player) {
    let score = 0;
    for (const dir of directions) {
        const line = getLineString(x, y, dir.dx, dir.dy, player);
        if (patterns.five.test(line)) score += scoreTable.five;
        else if (patterns.activeFour.test(line)) score += scoreTable.activeFour;
        else if (patterns.rushFour.test(line)) score += scoreTable.rushFour;
        else if (patterns.activeThree.test(line)) score += scoreTable.activeThree;
        else if (patterns.sleepThree.test(line)) score += scoreTable.sleepThree;
        else if (patterns.activeTwo.test(line)) score += scoreTable.activeTwo;
    }
    return score;
}
```

### 4.5 VCF搜索

```javascript
searchVCF(player, depth = 0, maxDepth = 10) {
    if (depth >= maxDepth) return null;

    const opponent = player === BLACK ? WHITE : BLACK;
    const fours = findFourMoves(player);    // 找冲四点

    for (const move of fours) {
        board[move.y][move.x] = player;

        if (checkWin(move.x, move.y, true).isWin) {
            board[move.y][move.x] = EMPTY;
            return move;  // 立即获胜
        }

        const defenses = findDefenseMoves(player, move);
        let allDefensesFail = true;

        for (const defense of defenses) {
            board[defense.y][defense.x] = opponent;
            const nextVCF = searchVCF(player, depth + 1, maxDepth);
            board[defense.y][defense.x] = EMPTY;

            if (!nextVCF) {
                allDefensesFail = false; // 有防守成功
                break;
            }
        }

        board[move.y][move.x] = EMPTY;
        if (allDefensesFail && defenses.length > 0) return move;
    }
    return null;
}
```

**要点**:
- 只考虑冲四（四连缺一）的落点
- 对手所有防守点必须全部失败才能确定为VCF
- 深度限制默认10步，可配置

### 4.6 威胁序列分析（Threat Space Search）

```javascript
searchThreatSequence(aiPlayer, opponent) {
    const candidates = getCandidateMoves(2, 25);
    let bestMove = null;
    let bestScore = -Infinity;

    for (const move of candidates) {
        board[move.y][move.x] = aiPlayer;
        const threats = analyzeThreat(move.x, move.y, aiPlayer);
        const opponentThreats = countOpponentThreats(opponent);
        const score = threats.score - opponentThreats * 0.8;
        board[move.y][move.x] = 0;

        if (score > bestScore && !isForbiddenMoveForPlayer(aiPlayer, move.x, move.y)) {
            bestScore = score;
            bestMove = {...move, score};
        }
    }
    return bestMove;
}
```

---

## 5. VCF练习逻辑

### 5.1 数据结构

```javascript
puzzle = {
    id: 'vcf-level1-001',
    title: '星位金钩',
    description: '黑棋补上缺口即可冲四',
    difficulty: '入门',
    layout: [ [x, y, player], ... ],
    minMoves: 1,
    maxMoves: 6,
    tags: ['入门', '金钩'],
    hints: ['先在星位补子', '注意白棋封口'],
    solution: [
        { x: 8, y: 7, player: 1, desc: '补中间' },
        { x: 9, y: 7, player: 2, desc: '白棋挡右侧' },
        ...
    ]
}
```

### 5.2 练习流程

```
startVCFPractice(level)
    ↓
随机选题 (未完成优先)
    ↓
调用 game.loadCustomState(board)
    ↓
玩家落子
    ↓
validateMove(x, y)
    ├→ 正确 → advanceStep()
    │          ├→ 若完成 → 奖励提示 + 记录时间
    │          └→ AI防守 (searchVCFDefense)
    └→ 错误 → 提示正确坐标 + 高亮
```

### 5.3 进度存储

```javascript
progress = {
    version: 'v3',
    lastLevel: 2,
    puzzlesCompleted: { 'vcf-level1-001': true, ... },
    bestTimes: { 'vcf-level1-001': 23.4, ... },
    streak: 3
}

localStorage.setItem('vcf_practice_progress_v3', JSON.stringify(progress))
```

**自动升级规则**: 每完成5题自动提升难度，最高4级。

---

## 6. 实战技巧 (AI实现建议)

### 6.1 活三/活四检测建议
- 使用长度9的窗口（落点±4格），足以覆盖所有必要模式
- 视边界为堵塞 (`3 → 2`) ，避免越界影响判断
- 匹配模式时需确保不包含更长连线（避免将活四误判为活三）

### 6.2 评分表参考

```javascript
aiScoreTable = {
    five: 1_000_000,
    openFour: 160_000,
    closedFour: 42_000,
    brokenFour: 55_000,
    openThree: 12_000,
    closedThree: 2_600,
    brokenThree: 6_200,
    openTwo: 600,
    closedTwo: 150,
    baseOpen: 35,
    doubleOpenFour: 420_000,
    doubleOpenThree: 36_000
};
```

### 6.3 AI调度策略
- 在demo.js中，AI落子通过`setTimeout`延迟执行
- 通过`aiThinking`状态锁定界面，防止玩家重复点击
- PvE模式AI执白，EvE模式黑白双方均调用AI

---

## 7. 重点注意事项

1. **胜利优先于禁手**: 若黑棋落子形成五连，同时构成禁手，应判定为胜利（代码中先`checkWin`再`checkForbidden`）
2. **禁止玩家在EvE模式落子**: board-renderer需检测`gameMode === 'EvE'`
3. **VCF模式与其他模式隔离**: 练习模式中不允许使用悔棋、保存、回放等功能
4. **AI调用应与game状态同步**: 每次AI落子后需调用`handleMoveResult`
5. **禁手消息统一处理**: `demo.handleForbiddenMove`负责显示模态、提示、日志

---

## 8. 调试工具

```javascript
window.GameDebug = {
    board: () => console.table(game.getBoardState()),
    moves: () => console.table(game.getMoves()),
    check: (x, y) => game.checkForbidden(x, y),
    aiHint: () => boardRenderer.highlightHintPosition(gameHint.x, gameHint.y)
};
```

---

## 9. 测试清单

| 测试项 | 用例 |
|--------|------|
| 勝负判定 | 横/竖/斜五连，边界五连 |
| 禁手检测 | 三三/四四/长连/非禁手边界 |
| AI决策 | 迫赢局面、需要防守的局面 |
| VCF练习 | 正确/错误走法，进度保存 |
| 模式切换 | 顺序切换，状态重置 |
| 存档恢复 | 进行中棋局的保存/加载 |

---

**下一步推荐阅读**: [04_UI设计与交互规范.md](./04_UI设计与交互规范.md)
