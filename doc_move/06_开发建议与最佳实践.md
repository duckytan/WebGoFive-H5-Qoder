# 06 - 开发建议与最佳实践

> **目标**: 确保代码质量、可维护性、性能优化，避免常见陷阱

---

## 1. 编码规范

### 1.1 命名约定

| 类型 | 格式 | 示例 |
|------|------|------|
| 类名 | PascalCase | `GomokuGame`, `SimpleBoardRenderer` |
| 函数/方法 | camelCase | `placePiece()`, `checkWin()` |
| 常量 | UPPER_SNAKE_CASE | `BOARD_SIZE`, `EMPTY`, `BLACK` |
| 变量 | camelCase | `currentPlayer`, `moveCount` |
| 私有属性 | _camelCase (可选) | `_internalState` |
| CSS类 | kebab-case | `game-board`, `btn--primary` |

### 1.2 注释规范

**JSDoc风格**:
```javascript
/**
 * 落子
 * @param {number} x - X坐标 (0-14)
 * @param {number} y - Y坐标 (0-14)
 * @returns {Object} {success: boolean, error?: string, ...}
 */
placePiece(x, y) {
    // 实现...
}
```

**中文注释**: 用户提示、业务逻辑可用中文  
**英文注释**: 算法细节、技术实现推荐英文

### 1.3 模块导出模板

```javascript
class ModuleName {
    constructor() {
        console.log('[ModuleName] 模块已初始化');
    }
    // ...
}

// 模块信息
const MODULE_INFO = {
    name: 'ModuleName',
    version: '1.0.0',
    dependencies: ['DependencyA', 'DependencyB']
};

ModuleName.__moduleInfo = MODULE_INFO;

// 导出到全局
if (typeof window !== 'undefined') {
    window.ModuleName = ModuleName;
    
    // 可选：触发模块加载事件
    window.dispatchEvent(new CustomEvent('moduleLoaded', {
        detail: MODULE_INFO
    }));
}
```

---

## 2. 错误处理

### 2.1 防御性编程

```javascript
// ✅ 推荐
function placePiece(x, y) {
    if (!this.isValidPosition(x, y)) {
        console.warn(`[Game] 无效坐标: (${x}, ${y})`);
        return { success: false, error: '坐标超出范围', code: 'INVALID_POSITION' };
    }
    
    if (!window.boardRenderer) {
        console.error('[Game] boardRenderer未初始化');
        return { success: false, error: '系统错误', code: 'RENDERER_NOT_INITIALIZED' };
    }
    
    // 正常逻辑...
}

// ❌ 避免
function placePiece(x, y) {
    this.board[y][x] = 1;  // 没有检查，可能越界或未初始化
}
```

### 2.2 错误返回格式统一

```javascript
// 成功
{ success: true, data: {...} }

// 失败
{ success: false, error: '错误描述', code: 'ERROR_CODE', details: {...} }
```

### 2.3 捕获异常

```javascript
try {
    const data = JSON.parse(jsonString);
    this.restoreState(data);
} catch (error) {
    console.error('[SaveLoad] 解析失败:', error);
    GameUtils.showMessage('数据格式错误', 'error');
    return false;
}
```

---

## 3. 性能优化

### 3.1 Canvas渲染优化

```javascript
// ✅ 仅在状态变化时渲染
this.needsRedraw = true;

requestAnimationFrame(() => {
    if (this.needsRedraw) {
        this.render();
        this.needsRedraw = false;
    }
});

// ❌ 避免每帧都渲染
setInterval(() => this.render(), 16);
```

### 3.2 AI搜索优化

```javascript
// ✅ 候选点限制
getCandidateMoves(range = 2, limit = 25) {
    // 只搜索已有棋子附近
    // ...
    return candidates.slice(0, limit);
}

// ✅ Alpha-Beta剪枝
if (beta <= alpha) break;

// ❌ 避免全局搜索
for (let x = 0; x < 15; x++) {
    for (let y = 0; y < 15; y++) {
        if (board[y][x] === 0) candidates.push({x, y});
    }
}
```

### 3.3 事件节流/防抖

```javascript
// 使用GameUtils提供的工具
const throttledRender = GameUtils.throttle(() => {
    this.render();
}, 100);

canvas.addEventListener('mousemove', throttledRender);
```

---

## 4. 代码复用

### 4.1 使用GameUtils

```javascript
// ✅ 使用工具函数
GameUtils.showMessage('落子成功', 'success');
const clonedBoard = GameUtils.deepClone(this.board);
GameUtils.downloadAsJSON(data, filename);

// ❌ 重复实现
function showMessage(msg) { /* ... */ }
function deepClone(obj) { /* ... */ }
```

### 4.2 公共方法提取

```javascript
// ✅ 提取公共逻辑
getLine(x, y, dx, dy, player) {
    // 四个方向都使用此方法
}

// ❌ 重复代码
checkHorizontal() { /* 类似逻辑 */ }
checkVertical()   { /* 类似逻辑 */ }
checkDiagonal()   { /* 类似逻辑 */ }
```

---

## 5. 状态管理

### 5.1 单一数据源

```javascript
// ✅ game-core.js 是唯一数据源
this.board        // 棋盘状态
this.currentPlayer // 当前玩家
this.gameStatus   // 游戏状态

// 其他模块通过API访问
boardRenderer.board = window.game.getBoardState();
```

### 5.2 状态同步

```javascript
// ✅ 修改状态后立即同步
game.placePiece(x, y);
boardRenderer.board = game.getBoardState();
boardRenderer.render();

demo.updateModeDisplay();
```

### 5.3 避免副作用

```javascript
// ✅ 纯函数
function checkWin(board, x, y) {
    // 不修改board，只返回结果
    return { isWin: true, ... };
}

// ❌ 有副作用
function checkWin(x, y) {
    this.winner = this.currentPlayer;  // 直接修改状态
}
```

---

## 6. 模块化设计

### 6.1 职责单一

| 模块 | 职责 | 不应包含 |
|------|------|----------|
| game-core | 游戏逻辑 | UI操作、渲染 |
| board-renderer | 渲染 | 业务逻辑 |
| demo | UI协调 | 算法实现 |

### 6.2 依赖注入

```javascript
// ✅ 通过参数传递依赖
class GameReplay {
    constructor(game, renderer) {
        this.game = game;
        this.renderer = renderer;
    }
}

// ❌ 硬编码依赖
class GameReplay {
    constructor() {
        this.game = window.game;  // 紧耦合
    }
}
```

---

## 7. 测试友好

### 7.1 可测试的代码

```javascript
// ✅ 易于测试
function evaluatePosition(board, x, y, player) {
    // 纯函数，易于单元测试
}

// ❌ 难以测试
function evaluatePosition(x, y) {
    const board = this.board;  // 依赖实例状态
    const player = this.currentPlayer;
    // ...
}
```

### 7.2 提供测试接口

```javascript
// 在game-core.js中
if (typeof window !== 'undefined') {
    window.GameDebug = {
        getBoard: () => game.getBoardState(),
        checkForbidden: (x, y) => game.checkForbidden(x, y),
        testAI: () => game.getAIMove('HELL')
    };
}
```

---

## 8. 用户体验

### 8.1 及时反馈

```javascript
// ✅ 操作立即反馈
button.addEventListener('click', (e) => {
    button.classList.add('active');
    
    setTimeout(() => {
        executeAction();
        button.classList.remove('active');
    }, 200);
});
```

### 8.2 友好的错误提示

```javascript
// ✅ 用户能理解的错误
GameUtils.showMessage('此位置已有棋子，请选择其他位置', 'warning');

// ❌ 技术术语
console.error('POSITION_OCCUPIED at board[7][7]');
```

### 8.3 加载状态

```javascript
// ✅ AI思考时显示状态
this.aiThinking = true;
document.getElementById('ai-thinking').style.display = 'block';

setTimeout(() => {
    executeAIMove();
    this.aiThinking = false;
    document.getElementById('ai-thinking').style.display = 'none';
}, thinkTime);
```

---

## 9. 安全性

### 9.1 输入验证

```javascript
// ✅ 验证所有输入
loadGameFromData(data) {
    if (!data || typeof data !== 'object') {
        throw new Error('无效的数据格式');
    }
    
    if (!Array.isArray(data.moves) || data.moves.length > 225) {
        throw new Error('移动记录异常');
    }
    
    // ...
}
```

### 9.2 避免eval

```javascript
// ❌ 永远不要使用
eval(userInput);

// ✅ 使用JSON.parse
JSON.parse(userInput);
```

### 9.3 LocalStorage安全

```javascript
// ✅ 捕获错误
try {
    localStorage.setItem(key, JSON.stringify(data));
} catch (error) {
    if (error.name === 'QuotaExceededError') {
        GameUtils.showMessage('存储空间不足', 'error');
    }
}
```

---

## 10. 可维护性

### 10.1 Magic Number避免

```javascript
// ❌ Magic Number
if (line.length >= 5) { /* ... */ }
if (this.board.length === 15) { /* ... */ }

// ✅ 常量
const BOARD_SIZE = 15;
const WIN_LENGTH = 5;

if (line.length >= WIN_LENGTH) { /* ... */ }
```

### 10.2 配置集中管理

```javascript
// ✅ 配置对象
const AI_CONFIG = {
    BEGINNER: { depth: 2, thinkTime: 500 },
    NORMAL:   { depth: 3, thinkTime: 1000 },
    HARD:     { depth: 4, thinkTime: 1800 },
    HELL:     { depth: 5, thinkTime: 2500 }
};
```

### 10.3 日志规范

```javascript
// ✅ 带前缀的日志
console.log('[GameCore] 游戏开始');
console.warn('[BoardRenderer] Canvas尺寸异常');
console.error('[SaveLoad] 加载失败:', error);
```

---

## 11. Git最佳实践

### 11.1 提交信息
```
feat: 新增VCF练习模式
fix: 修复禁手检测bug
docs: 更新README
refactor: 重构AI搜索算法
style: 调整棋盘样式
test: 增加单元测试
```

### 11.2 .gitignore
```
.DS_Store
node_modules/
*.log
.idea/
.vscode/
dist/
```

---

## 12. 常见陷阱

### 12.1 坐标混淆
```javascript
// ⚠️ 注意: board是[y][x]
const cell = this.board[y][x];  // ✅ 正确
const cell = this.board[x][y];  // ❌ 错误
```

### 12.2 临时状态未恢复
```javascript
// ⚠️ 检测禁手时要恢复
this.board[y][x] = player;
const result = checkForbidden(x, y);
this.board[y][x] = 0;  // 必须恢复
```

### 12.3 异步状态错乱
```javascript
// ⚠️ AI思考时避免玩家操作
if (this.aiThinking) {
    console.warn('AI思考中，请稍候');
    return;
}
```

---

**总结**: 遵循这些最佳实践，可以显著提高代码质量和开发效率

**下一步**: 参考[07_核心代码示例与模板](./07_核心代码示例与模板.md)获取可用代码模板
