# 07 - 核心代码示例与模板

> **目的**: 提供可直接复制的代码片段，帮助AI快速实现关键功能

---

## 1. 模块导出模板

```javascript
class ModuleName {
    constructor(options = {}) {
        this.options = options;
        console.log(`[ModuleName] 初始化完成 (v${ModuleName.__moduleInfo.version})`);
    }
    
    init() {
        // 初始化逻辑
    }
}

const MODULE_INFO = {
    name: 'ModuleName',
    version: '1.0.0',
    author: '项目团队',
    dependencies: []
};

ModuleName.__moduleInfo = MODULE_INFO;

if (typeof window !== 'undefined') {
    window.ModuleName = ModuleName;
    window.dispatchEvent?.(new CustomEvent('moduleLoaded', { detail: MODULE_INFO }));
}
```

---

## 2. 棋盘与落子模板

```javascript
class GomokuGame {
    constructor() {
        this.boardSize = 15;
        this.board = Array(this.boardSize).fill().map(() => Array(this.boardSize).fill(0));
        this.currentPlayer = 1;  // 1=黑, 2=白
        this.gameStatus = 'ready';
        this.moves = [];
    }
    
    isValidPosition(x, y) {
        return x >= 0 && x < this.boardSize && y >= 0 && y < this.boardSize;
    }
    
    placePiece(x, y) {
        if (!this.isValidPosition(x, y)) {
            return { success: false, error: '坐标超出范围', code: 'INVALID_POSITION' };
        }
        
        if (this.board[y][x] !== 0) {
            return { success: false, error: '该位置已有棋子', code: 'POSITION_OCCUPIED' };
        }
        
        this.board[y][x] = this.currentPlayer;
        this.moves.push({ x, y, player: this.currentPlayer, timestamp: Date.now(), step: this.moves.length + 1 });
        
        const winResult = this.checkWin(x, y);
        if (winResult.isWin) {
            this.gameStatus = 'finished';
            this.winner = this.currentPlayer;
            return { success: true, gameOver: true, winner: this.currentPlayer, winLine: winResult.winLine };
        }
        
        if (this.moves.length === this.boardSize * this.boardSize) {
            this.gameStatus = 'finished';
            this.winner = 0;
            return { success: true, gameOver: true, winner: 0 };
        }
        
        this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
        return { success: true, gameOver: false, nextPlayer: this.currentPlayer };
    }
    
    checkWin(x, y) {
        const player = this.board[y][x];
        const directions = [
            { dx: 1, dy: 0 }, { dx: 0, dy: 1 },
            { dx: 1, dy: 1 }, { dx: 1, dy: -1 }
        ];
        
        for (const dir of directions) {
            const line = this.getLine(x, y, dir.dx, dir.dy, player);
            if (line.length >= 5) {
                return { isWin: true, winLine: line };
            }
        }
        return { isWin: false };
    }
    
    getLine(x, y, dx, dy, player) {
        const line = [{ x, y }];
        
        let nx = x + dx;
        let ny = y + dy;
        while (this.isValidPosition(nx, ny) && this.board[ny][nx] === player) {
            line.push({ x: nx, y: ny });
            nx += dx; ny += dy;
        }
        
        nx = x - dx;
        ny = y - dy;
        while (this.isValidPosition(nx, ny) && this.board[ny][nx] === player) {
            line.unshift({ x: nx, y: ny });
            nx -= dx; ny -= dy;
        }
        
        return line;
    }
}
```

---

## 3. 禁手检测模板

```javascript
checkForbidden(x, y) {
    const result = { isForbidden: false, type: null, details: {} };
    if (this.currentPlayer !== 1) return result;

    this.board[y][x] = 1;  // 临时落子

    const longLine = this.checkLongLine(x, y, 1);
    if (longLine.hasLongLine) {
        this.board[y][x] = 0;
        return { isForbidden: true, type: '长连禁手', details: longLine };
    }

    const openThrees = this.countOpenThrees(x, y, 1);
    const openFours = this.countOpenFours(x, y, 1);

    this.board[y][x] = 0;  // 恢复

    if (openFours.total >= 2) {
        return { isForbidden: true, type: '四四禁手', details: { openThrees, openFours } };
    }

    if (openThrees.total >= 2) {
        return { isForbidden: true, type: '三三禁手', details: { openThrees, openFours } };
    }

    return result;
}
```

---

## 4. Canvas渲染模板

```javascript
class SimpleBoardRenderer {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.boardSize = 15;
        this.cellSize = 36;
        this.padding = 30;
        this.board = window.game?.getBoardState() || this.createEmptyBoard();
        this.setupEventListeners();
        this.render();
    }
    
    render() {
        const ctx = this.ctx;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.drawBoard(ctx);
        this.drawPieces(ctx);
        this.drawHover(ctx);
        this.drawHighlights(ctx);
    }
    
    drawBoard(ctx) {
        ctx.fillStyle = '#f4e4bc';
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1.5;
        
        for (let i = 0; i < this.boardSize; i++) {
            const offset = this.padding + i * this.cellSize;
            ctx.beginPath();
            ctx.moveTo(this.padding, offset);
            ctx.lineTo(this.padding + (this.boardSize - 1) * this.cellSize, offset);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(offset, this.padding);
            ctx.lineTo(offset, this.padding + (this.boardSize - 1) * this.cellSize);
            ctx.stroke();
        }
        
        this.drawStarPoints(ctx);
    }
    
    drawPieces(ctx) {
        for (let y = 0; y < this.boardSize; y++) {
            for (let x = 0; x < this.boardSize; x++) {
                const cell = this.board[y][x];
                if (cell === 0) continue;
                const cx = this.padding + x * this.cellSize;
                const cy = this.padding + y * this.cellSize;
                this.drawPiece(ctx, cx, cy, cell);
            }
        }
    }
    
    drawPiece(ctx, cx, cy, player) {
        const gradient = ctx.createRadialGradient(cx - 5, cy - 5, 5, cx, cy, 20);
        if (player === 1) {
            gradient.addColorStop(0, '#555');
            gradient.addColorStop(1, '#111');
        } else {
            gradient.addColorStop(0, '#fff');
            gradient.addColorStop(1, '#ccc');
        }
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(cx, cy, 14, 0, Math.PI * 2);
        ctx.fill();
    }
}
```

---

## 5. AI决策模板

```javascript
class AdvancedAI {
    constructor(game) {
        this.game = game;
        this.scoreTable = {
            five: 1000000,
            activeFour: 160000,
            rushFour: 42000,
            activeThree: 12000,
            sleepThree: 2600,
            activeTwo: 600
        };
        this.patterns = this.initPatterns();
    }
    
    initPatterns() {
        return {
            five: /11111/,
            activeFour: /011110/,
            rushFour: /(01111|11110|11011|11101|10111)/,
            activeThree: /(01110|011010|010110)/,
            sleepThree: /(00111|11100|11010|01011|10110|01101)/
        };
    }
    
    getMove(difficulty = 'NORMAL') {
        const aiPlayer = this.game.currentPlayer;
        const opponent = aiPlayer === 1 ? 2 : 1;
        
        // 1. 立即获胜
        const winMove = this.findWinningMove(aiPlayer);
        if (winMove) return winMove;
        
        // 2. 阻止对手
        const blockMove = this.findWinningMove(opponent);
        if (blockMove) return blockMove;
        
        // 3. 搜索最佳落点
        return this.iterativeDeepeningSearch(aiPlayer, opponent, this.getDepth(difficulty));
    }
}
```

---

## 6. VCF练习模板

```javascript
class VCFPracticeManager {
    constructor() {
        this.puzzles = this.initializePuzzles();
        this.currentPuzzle = null;
        this.currentLevel = 1;
        this.progress = this.loadProgress();
    }
    
    initializePuzzles() {
        const puzzles = [];
        puzzles.push(...this.generateLevel1Puzzles());
        puzzles.push(...this.generateLevel2Puzzles());
        puzzles.push(...this.generateLevel3Puzzles());
        puzzles.push(...this.generateLevel4Puzzles());
        return puzzles;
    }
    
    getRandomPuzzle(level = 1) {
        const pool = this.puzzles.filter(p => p.level === level);
        const unfinished = pool.filter(p => !this.progress.completed[p.id]);
        const list = unfinished.length > 0 ? unfinished : pool;
        const puzzle = list[Math.floor(Math.random() * list.length)];
        this.currentPuzzle = puzzle;
        this.currentStep = 0;
        return puzzle;
    }
    
    validateMove(x, y) {
        const step = this.currentPuzzle.solution[this.currentStep];
        const isCorrect = step.x === x && step.y === y;
        
        if (isCorrect) {
            this.currentStep++;
            if (this.currentStep >= this.currentPuzzle.solution.length) {
                this.completePuzzle();
            }
            return { success: true, nextStep: this.currentStep };
        }
        
        return { success: false, correctMove: step };
    }
}
```

---

## 7. 存档/回放模板

```javascript
class GameSaveLoad {
    constructor() {
        this.currentGameData = null;
        document.getElementById('save-game-btn').addEventListener('click', () => this.saveGame());
        document.getElementById('load-game-btn').addEventListener('click', () => this.loadGame());
    }
    
    getCurrentGameData() {
        const exportData = window.game.exportData();
        return {
            version: exportData.version,
            boardState: exportData.boardState,
            moves: exportData.moves,
            currentPlayer: window.game.currentPlayer,
            gameMode: window.game.gameMode,
            aiDifficulty: window.game.aiDifficulty,
            timestamp: Date.now()
        };
    }
}
```

---

## 8. UI事件模板

```javascript
class InterfaceDemo {
    setupEventListeners() {
        document.getElementById('new-game-btn').addEventListener('click', () => this.startNewGame());
        document.getElementById('undo-btn').addEventListener('click', () => this.undoMove());
        document.getElementById('mode-toggle-btn').addEventListener('click', () => this.toggleGameMode());
        document.getElementById('hint-btn').addEventListener('click', () => this.showHint());
        
        document.addEventListener('keydown', (event) => {
            if (event.ctrlKey && event.key === 'n') {
                this.startNewGame();
            }
        });
    }
}
```

---

## 9. 提示系统模板

```javascript
showHint() {
    const now = Date.now();
    if (now - this.lastHintTime < this.hintCooldown) {
        const remaining = Math.ceil((this.hintCooldown - (now - this.lastHintTime)) / 1000);
        this.updateHintMessage(`提示冷却中（${remaining}秒）`, 'warning');
        return;
    }
    
    if (this.gameMode !== 'PvE' && this.gameMode !== 'PvP') {
        this.updateHintMessage('当前模式不支持提示', 'warning');
        return;
    }
    
    const hintMove = window.game.getHintMove();
    if (!hintMove) {
        this.updateHintMessage('暂无提示', 'info');
        return;
    }
    
    this.lastHintTime = now;
    window.boardRenderer.highlightHintPosition(hintMove.x, hintMove.y, { duration: 5000 });
    this.updateHintMessage(`建议落子：${GameUtils.positionToNotation(hintMove.x, hintMove.y)}`, 'info');
}
```

---

## 10. 常用常量

```javascript
const BOARD_SIZE = 15;
const EMPTY = 0;
const BLACK = 1;
const WHITE = 2;

const GAME_MODES = {
    PVP: 'PvP',
    PVE: 'PvE',
    EVE: 'EvE',
    VCF: 'VCF_PRACTICE'
};

const AI_LEVELS = {
    BEGINNER: { name: '新手', depth: 2, thinkTime: 500 },
    NORMAL:   { name: '正常', depth: 3, thinkTime: 1000 },
    HARD:     { name: '困难', depth: 4, thinkTime: 1500 },
    HELL:     { name: '地狱', depth: 5, thinkTime: 2000 }
};
```

---

**提示**: 以上模板可直接复制到对应文件中，根据需求调整细节

**下一步**: 参考[08_测试与部署指南](./08_测试与部署指南.md)完成验证
