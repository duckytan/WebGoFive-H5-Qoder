# äº”å­æ£‹è§„åˆ™ä¸ç®—æ³•æ ¸å¿ƒçŸ¥è¯†

## ğŸ¯ åŸºç¡€è§„åˆ™

### æ£‹ç›˜ä¸æ£‹å­
- **æ£‹ç›˜**ï¼š15Ã—15çº¿äº¤å‰æ£‹ç›˜ï¼ˆ225ä¸ªäº¤å‰ç‚¹ï¼‰
- **æ£‹å­**ï¼šé»‘ç™½ä¸¤è‰²ï¼Œé»‘æ£‹å…ˆæ‰‹
- **è·èƒœæ¡ä»¶**ï¼šæ¨ªã€ç«–ã€æ–œä»»ä¸€æ–¹å‘è¿æˆäº”å­

### åæ ‡ç³»ç»Ÿ
```
   0 1 2 3 4 5 6 7 8 9 A B C D E
0  â”Œâ”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”¬â”€â”
1  â”œâ”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¤
2  â”œâ”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¤
...
7  â”œâ”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â˜…â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¼â”€â”¤  å¤©å…ƒä½ç½®(7,7)
...
```

---

## ğŸš« ç¦æ‰‹è§„åˆ™è¯¦è§£

### 1. ä¸‰ä¸‰ç¦æ‰‹

#### ä»€ä¹ˆæ˜¯æ´»ä¸‰ï¼Ÿ
æ´»ä¸‰æŒ‡ä¸¤ç«¯éƒ½æœ‰ç©ºä½å¯ä»¥å»¶ä¼¸æˆæ´»å››çš„ä¸‰å­è¿çº¿ã€‚

#### æ´»ä¸‰çš„æ‰€æœ‰å½¢æ€
```javascript
// 1. è¿ä¸‰å‹æ´»ä¸‰
'_â—â—â—_'      // æ ‡å‡†è¿ä¸‰ï¼Œéœ€è¦5æ ¼ç©ºé—´

// 2. è·³ä¸‰å‹æ´»ä¸‰  
'_â—â—_â—_'     // è¿äºŒè·³ä¸€ï¼Œéœ€è¦6æ ¼ç©ºé—´
'_â—_â—â—_'     // è·³ä¸€è¿äºŒï¼Œéœ€è¦6æ ¼ç©ºé—´
```

#### ä¸‰ä¸‰ç¦æ‰‹åˆ¤å®š
```javascript
function isDoubleThree(board, x, y, player) {
    if (player !== 1) return false; // åªå¯¹é»‘æ£‹æœ‰æ•ˆ
    
    let liveThreeCount = 0;
    const directions = [
        [1, 0],   // æ°´å¹³
        [0, 1],   // å‚ç›´  
        [1, 1],   // ä¸»å¯¹è§’çº¿
        [1, -1]   // å‰¯å¯¹è§’çº¿
    ];
    
    for (const [dx, dy] of directions) {
        if (checkLiveThreeInDirection(board, x, y, dx, dy, player)) {
            liveThreeCount++;
        }
    }
    
    return liveThreeCount >= 2;
}
```

### 2. å››å››ç¦æ‰‹

#### å››çš„ç±»å‹
```javascript
// æ´»å››ï¼šä¸¤ç«¯éƒ½èƒ½æˆäº”
'_â—â—â—â—_'

// å†²å››ï¼šåªæœ‰ä¸€ç«¯èƒ½æˆäº”
'â—â—â—â—_'  æˆ–  '_â—â—â—â—'  æˆ–  'â—â—_â—â—'
```

#### å››å››ç¦æ‰‹åˆ¤å®š
```javascript
function isDoubleFour(board, x, y, player) {
    if (player !== 1) return false;
    
    let fourCount = 0;
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        if (checkFourInDirection(board, x, y, dx, dy, player)) {
            fourCount++;
        }
    }
    
    return fourCount >= 2;
}
```

### 3. é•¿è¿ç¦æ‰‹

#### é•¿è¿åˆ¤å®š
```javascript
function isOverline(board, x, y, player) {
    if (player !== 1) return false;
    
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        const count = countLineInDirection(board, x, y, dx, dy, player);
        if (count >= 6) {
            return true;
        }
    }
    
    return false;
}
```

---

## ğŸ” æ£€æµ‹ç®—æ³•å®ç°

### è¿å­è®¡æ•°ç®—æ³•
```javascript
function countLineInDirection(board, x, y, dx, dy, player) {
    let count = 1; // åŒ…å«å½“å‰ä½ç½®
    
    // å‘æ­£æ–¹å‘è®¡æ•°
    let i = 1;
    while (true) {
        const nx = x + i * dx;
        const ny = y + i * dy;
        
        if (!isValidPosition(nx, ny) || board.getPiece(nx, ny) !== player) {
            break;
        }
        count++;
        i++;
    }
    
    // å‘è´Ÿæ–¹å‘è®¡æ•°
    i = 1;
    while (true) {
        const nx = x - i * dx;
        const ny = y - i * dy;
        
        if (!isValidPosition(nx, ny) || board.getPiece(nx, ny) !== player) {
            break;
        }
        count++;
        i++;
    }
    
    return count;
}
```

### æ´»ä¸‰æ£€æµ‹ç®—æ³•
```javascript
function checkLiveThreeInDirection(board, x, y, dx, dy, player) {
    // æ£€æŸ¥è¿ä¸‰å‹æ´»ä¸‰ _â—â—â—_
    if (checkConnectedThree(board, x, y, dx, dy, player)) {
        return true;
    }
    
    // æ£€æŸ¥è·³ä¸‰å‹æ´»ä¸‰
    if (checkJumpThree(board, x, y, dx, dy, player)) {
        return true;
    }
    
    return false;
}

function checkConnectedThree(board, x, y, dx, dy, player) {
    // æ¨¡æ‹Ÿæ”¾å­
    board.placePiece(x, y, player);
    
    let count = 1;
    let leftEmpty = false, rightEmpty = false;
    
    // å‘å³è®¡æ•°
    let rightCount = 0;
    for (let i = 1; i <= 3; i++) {
        const nx = x + i * dx, ny = y + i * dy;
        if (!isValidPosition(nx, ny)) break;
        
        if (board.getPiece(nx, ny) === player) {
            rightCount++;
        } else if (board.getPiece(nx, ny) === 0 && i === rightCount + 1) {
            rightEmpty = true;
            break;
        } else {
            break;
        }
    }
    
    // å‘å·¦è®¡æ•°
    let leftCount = 0;
    for (let i = 1; i <= 3; i++) {
        const nx = x - i * dx, ny = y - i * dy;
        if (!isValidPosition(nx, ny)) break;
        
        if (board.getPiece(nx, ny) === player) {
            leftCount++;
        } else if (board.getPiece(nx, ny) === 0 && i === leftCount + 1) {
            leftEmpty = true;
            break;
        } else {
            break;
        }
    }
    
    // æ’¤é”€æ¨¡æ‹Ÿ
    board.removePiece(x, y);
    
    // åˆ¤æ–­æ˜¯å¦æ„æˆæ´»ä¸‰
    count += leftCount + rightCount;
    return count === 3 && leftEmpty && rightEmpty;
}
```

---

## ğŸ® æ¸¸æˆçŠ¶æ€ç®¡ç†

### æ¸¸æˆçŠ¶æ€å®šä¹‰
```javascript
const GameStatus = {
    PLAYING: 'playing',
    BLACK_WIN: 'black_win',
    WHITE_WIN: 'white_win',
    DRAW: 'draw',
    PAUSED: 'paused'
};

const Player = {
    BLACK: 1,
    WHITE: 2,
    EMPTY: 0
};
```

### èƒœè´Ÿåˆ¤å®šç®—æ³•
```javascript
function checkWin(board, lastMove) {
    const { x, y, player } = lastMove;
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        const count = countLineInDirection(board, x, y, dx, dy, player);
        if (count >= 5) {
            return player; // è¿”å›è·èƒœç©å®¶
        }
    }
    
    return null; // æ— äººè·èƒœ
}
```

---

## ğŸ¤– AIç®—æ³•åŸºç¡€

### AIéš¾åº¦ç­‰çº§ç³»ç»Ÿ

é¡¹ç›®å®ç°äº†4ä¸ªAIéš¾åº¦ç­‰çº§ï¼Œæ¯ä¸ªçº§åˆ«éƒ½æœ‰ä¸åŒçš„ç®—æ³•å¤æ‚åº¦å’Œè®¡ç®—æ·±åº¦ï¼š

#### éš¾åº¦ç­‰çº§å®šä¹‰
```javascript
const AILevels = {
    BEGINNER: {
        name: 'æ–°æ‰‹',
        maxDepth: 2,
        useAlphaBeta: false,
        responseTime: 500,
        winRateTarget: 0.25 // è®©ç©å®¶æœ‰75%èƒœç‡
    },
    NORMAL: {
        name: 'æ­£å¸¸', 
        maxDepth: 4,
        useAlphaBeta: true,
        responseTime: 1000,
        winRateTarget: 0.5 // å¹³è¡¡å¯¹æˆ˜
    },
    HARD: {
        name: 'å›°éš¾',
        maxDepth: 8,
        useAdvancedSearch: true,
        responseTime: 2000,
        winRateTarget: 0.75 // AIä¼˜åŠ¿æ˜æ˜¾
    },
    HELL: {
        name: 'åœ°ç‹±',
        maxDepth: 12,
        useThreatSpace: true,
        responseTime: 3000,
        winRateTarget: 0.9 // æ¥è¿‘æ— æ•Œ
    }
};
```

### Minimaxç®—æ³•æ¡†æ¶
```javascript
class AIEngine {
    constructor(level = 'NORMAL') {
        this.level = AILevels[level];
        this.maxDepth = this.level.maxDepth;
        this.ruleEngine = new RuleEngine();
        this.threatAnalyzer = new ThreatAnalyzer();
        this.openingBook = new OpeningBook();
    }
    
    async makeMove(board, player) {
        const startTime = performance.now();
        
        // å¼€å±€åº“æŸ¥è¯¢ï¼ˆå›°éš¾çº§åˆ«ä»¥ä¸Šï¼‰
        if (this.level.name !== 'æ–°æ‰‹' && board.moveCount < 10) {
            const bookMove = this.openingBook.getMove(board);
            if (bookMove) return bookMove;
        }
        
        let bestMove;
        
        // æ ¹æ®éš¾åº¦é€‰æ‹©æœç´¢ç®—æ³•
        switch(this.level.name) {
            case 'æ–°æ‰‹':
                bestMove = await this.beginnerSearch(board, player);
                break;
            case 'æ­£å¸¸':
                bestMove = await this.normalSearch(board, player);
                break;
            case 'å›°éš¾':
                bestMove = await this.hardSearch(board, player);
                break;
            case 'åœ°ç‹±':
                bestMove = await this.hellSearch(board, player);
                break;
        }
        
        // ç¡®ä¿å“åº”æ—¶é—´ä¸è¶…è¿‡é™åˆ¶
        const elapsed = performance.now() - startTime;
        if (elapsed < this.level.responseTime / 2) {
            await this.delay(this.level.responseTime / 2 - elapsed);
        }
        
        return bestMove;
    }
    
    // æ–°æ‰‹çº§åˆ« - ç®€å•æœç´¢
    async beginnerSearch(board, player) {
        const moves = this.generateBasicMoves(board);
        let bestMove = moves[0];
        let bestScore = -Infinity;
        
        for (const move of moves.slice(0, 5)) { // é™åˆ¶å€™é€‰ç§»åŠ¨æ•°
            const score = this.simpleEvaluate(board, move.x, move.y, player);
            if (score > bestScore) {
                bestScore = score;
                bestMove = move;
            }
        }
        
        return bestMove;
    }
    
    // æ­£å¸¸çº§åˆ« - Minimax + Alpha-Beta
    async normalSearch(board, player) {
        const [bestScore, bestMove] = this.minimax(
            board, this.maxDepth, -Infinity, Infinity, true, player
        );
        return bestMove;
    }
    
    // å›°éš¾çº§åˆ« - é«˜çº§æœç´¢ + å¨èƒåˆ†æ
    async hardSearch(board, player) {
        // å…ˆæ£€æŸ¥æ˜¯å¦æœ‰ç«‹å³è·èƒœçš„æœºä¼š
        const winningMove = this.findWinningMove(board, player);
        if (winningMove) return winningMove;
        
        // æ£€æŸ¥æ˜¯å¦éœ€è¦é˜²å¾¡
        const defensiveMove = this.findDefensiveMove(board, player);
        if (defensiveMove && defensiveMove.urgent) return defensiveMove.move;
        
        // å¨èƒåºåˆ—æœç´¢
        const threatMove = this.threatSpaceSearch(board, player, 6);
        if (threatMove) return threatMove;
        
        // å¸¸è§„æœç´¢
        const [bestScore, bestMove] = this.advancedMinimax(
            board, this.maxDepth, -Infinity, Infinity, true, player
        );
        return bestMove;
    }
    
    // åœ°ç‹±çº§åˆ« - å®Œæ•´å¨èƒç©ºé—´æœç´¢
    async hellSearch(board, player) {
        // å®Œæ•´çš„å¨èƒåˆ†æ
        const completeAnalysis = await this.completeGameAnalysis(board, player);
        
        if (completeAnalysis.certainWin) {
            return completeAnalysis.winningMove;
        }
        
        // è¯æ˜æ•°æœç´¢å¯»æ‰¾ç¡®å®šç»“æœ
        const proofMove = this.proofNumberSearch(board, player);
        if (proofMove) return proofMove;
        
        // ç¥ç»ç½‘ç»œè¾…åŠ©è¯„ä¼°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
        if (this.neuralNetwork) {
            const nnMove = await this.neuralNetworkSearch(board, player);
            if (nnMove.confidence > 0.8) return nnMove.move;
        }
        
        // æœ€æ·±å±‚æœç´¢
        const [bestScore, bestMove] = this.deepSearch(
            board, this.maxDepth, player
        );
        return bestMove;
    }
    
    minimax(board, depth, alpha, beta, isMaximizing, player) {
        // ç»ˆæ­¢æ¡ä»¶
        if (depth === 0 || this.isGameOver(board)) {
            return [this.evaluateBoard(board, player), null];
        }
        
        const moves = this.generateMoves(board);
        let bestMove = null;
        
        if (isMaximizing) {
            let maxEval = -Infinity;
            
            for (const move of moves) {
                board.placePiece(move.x, move.y, player);
                const [evalScore] = this.minimax(
                    board, depth - 1, alpha, beta, false, 3 - player
                );
                board.removePiece(move.x, move.y);
                
                if (evalScore > maxEval) {
                    maxEval = evalScore;
                    bestMove = move;
                }
                
                alpha = Math.max(alpha, evalScore);
                if (beta <= alpha) break; // Alpha-Betaå‰ªæ
            }
            
            return [maxEval, bestMove];
        } else {
            let minEval = Infinity;
            
            for (const move of moves) {
                board.placePiece(move.x, move.y, 3 - player);
                const [evalScore] = this.minimax(
                    board, depth - 1, alpha, beta, true, player
                );
                board.removePiece(move.x, move.y);
                
                if (evalScore < minEval) {
                    minEval = evalScore;
                    bestMove = move;
                }
                
                beta = Math.min(beta, evalScore);
                if (beta <= alpha) break;
            }
            
            return [minEval, bestMove];
        }
    }
}
```

### åˆ†çº§è¯„ä¼°å‡½æ•°ç³»ç»Ÿ

#### æ–°æ‰‹çº§åˆ« - ç®€å•è¯„ä¼°
```javascript
simpleEvaluate(board, x, y, player) {
    let score = 0;
    
    // åªè€ƒè™‘åŸºæœ¬è¿å­
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        const count = this.countConsecutive(board, x, y, dx, dy, player);
        
        // ç®€å•çš„åˆ†æ•°ç³»ç»Ÿ
        if (count >= 4) score += 1000;
        else if (count >= 3) score += 100;
        else if (count >= 2) score += 10;
    }
    
    // ä¸­å¿ƒä½ç½®åŠ åˆ†
    const centerDistance = Math.abs(x - 7) + Math.abs(y - 7);
    score += Math.max(0, 7 - centerDistance);
    
    return score;
}
```

#### æ­£å¸¸çº§åˆ« - æ¨¡å¼è¯†åˆ«è¯„ä¼°
```javascript
evaluateBoard(board, player) {
    let score = 0;
    
    // å¨èƒæ¨¡å¼è¯„ä¼°
    const threats = this.findAllThreats(board, player);
    const opponentThreats = this.findAllThreats(board, 3 - player);
    
    // è‡ªå·±çš„å¨èƒå¾—åˆ†
    score += this.scoreThreats(threats);
    
    // å¯¹æ‰‹çš„å¨èƒæ‰£åˆ†ï¼ˆç¨å¾®é‡è§†é˜²å¾¡ï¼‰
    score -= this.scoreThreats(opponentThreats) * 1.1;
    
    // ä½ç½®ä»·å€¼è¯„ä¼°
    score += this.evaluatePositionalValue(board, player);
    
    return score;
}

scoreThreats(threats) {
    let score = 0;
    
    for (const threat of threats) {
        switch(threat.type) {
            case 'FIVE': score += 100000; break;
            case 'OPEN_FOUR': score += 10000; break;
            case 'SIMPLE_FOUR': score += 1000; break;
            case 'OPEN_THREE': score += 200; break;
            case 'BROKEN_THREE': score += 50; break;
            case 'OPEN_TWO': score += 10; break;
        }
    }
    
    return score;
}
```

#### å›°éš¾çº§åˆ« - é«˜çº§å¨èƒåˆ†æ
```javascript
advancedEvaluate(board, player) {
    let score = 0;
    
    // å¨èƒåºåˆ—åˆ†æ
    const winningSequence = this.findWinningSequence(board, player, 6);
    if (winningSequence) {
        score += 50000 / winningSequence.length;
    }
    
    // é˜²å¾¡åºåˆ—åˆ†æ
    const defensiveNeeds = this.analyzeDefensiveNeeds(board, player);
    score -= this.scoreDefensiveUrgency(defensiveNeeds);
    
    // æ£‹ç›˜æ§åˆ¶è¯„ä¼°
    score += this.evaluateTerritoryControl(board, player);
    
    // å½¢åŠ¿åˆ¤æ–­
    score += this.evaluateGamePhase(board, player);
    
    return score;
}

// å¨èƒåºåˆ—æœç´¢ï¼ˆåŸºäºVictor Allisç†è®ºï¼‰
findWinningSequence(board, player, maxDepth) {
    const threats = this.generateAllThreats(board, player);
    const dependencyGraph = this.buildThreatDependencyGraph(threats);
    
    return this.searchThreatSequence(dependencyGraph, maxDepth);
}
```

#### åœ°ç‹±çº§åˆ« - å®Œæ•´åˆ†æè¯„ä¼°
```javascript
expertEvaluate(board, player) {
    // ç¥ç»ç½‘ç»œè¯„ä¼°ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    let nnScore = 0;
    if (this.neuralNetwork) {
        nnScore = this.neuralNetwork.evaluate(board, player);
    }
    
    // å®Œæ•´å¨èƒç©ºé—´åˆ†æ
    const threatSpaceScore = this.completeThreatSpaceAnalysis(board, player);
    
    // ä¸“å®¶æ¨¡å¼åº“è¯„ä¼°
    const patternScore = this.expertPatternEvaluation(board, player);
    
    // æˆ˜ç•¥ä½ç½®è¯„ä¼°
    const strategicScore = this.strategicEvaluation(board, player);
    
    // å¯¹æ‰‹å»ºæ¨¡è¯„ä¼°
    const opponentModelScore = this.opponentModelingScore(board, player);
    
    // åŠ¨æ€æƒé‡ç»„åˆ
    const gamePhase = this.determineGamePhase(board);
    
    return this.combineScores({
        neural: nnScore,
        threats: threatSpaceScore,
        patterns: patternScore,
        strategic: strategicScore,
        opponent: opponentModelScore
    }, gamePhase);
}

// è¯æ˜æ•°æœç´¢ - å¯»æ‰¾ç¡®å®šæ€§ç»“æœ
proofNumberSearch(board, player) {
    const pnNode = {
        proof: this.isWinning(board, player) ? 0 : Infinity,
        disproof: this.isLosing(board, player) ? 0 : Infinity
    };
    
    return this.expandPNNode(board, player, pnNode, 1000000); // æœ€å¤§èŠ‚ç‚¹æ•°
}
```

---

## ğŸ”§ å®ç”¨å·¥å…·å‡½æ•°

### åæ ‡éªŒè¯
```javascript
function isValidPosition(x, y) {
    return x >= 0 && x < 15 && y >= 0 && y < 15;
}
```

### æ–¹å‘å‘é‡
```javascript
const DIRECTIONS = {
    HORIZONTAL: [1, 0],
    VERTICAL: [0, 1],
    DIAGONAL_MAIN: [1, 1],
    DIAGONAL_ANTI: [1, -1]
};
```

### æ¨¡å¼åŒ¹é…
```javascript
function matchPattern(board, x, y, pattern, player) {
    // å°†å­—ç¬¦æ¨¡å¼è½¬æ¢ä¸ºæ•°å­—æ•°ç»„è¿›è¡ŒåŒ¹é…
    const patternArray = pattern.split('').map(char => {
        switch (char) {
            case 'â—': return player;
            case 'â—‹': return 3 - player;
            case '_': return 0;
            default: return -1;
        }
    });
    
    // åœ¨å››ä¸ªæ–¹å‘ä¸ŠåŒ¹é…æ¨¡å¼
    const directions = [[1,0], [0,1], [1,1], [1,-1]];
    
    for (const [dx, dy] of directions) {
        if (matchPatternInDirection(board, x, y, dx, dy, patternArray)) {
            return true;
        }
    }
    
    return false;
}
```

---

## ğŸ“ æ³¨æ„äº‹é¡¹

### 1. æ€§èƒ½ä¼˜åŒ–
- ä½¿ç”¨Alpha-Betaå‰ªæä¼˜åŒ–Minimax
- é™åˆ¶AIæœç´¢æ·±åº¦
- ç¼“å­˜é‡å¤è®¡ç®—ç»“æœ

### 2. è¾¹ç•Œå¤„ç†
- æ‰€æœ‰åæ ‡è®¿é—®å‰éƒ½è¦éªŒè¯æœ‰æ•ˆæ€§
- é˜²æ­¢æ•°ç»„è¶Šç•Œ
- å¤„ç†æ£‹ç›˜è¾¹ç¼˜çš„ç‰¹æ®Šæƒ…å†µ

### 3. è§„åˆ™ä¼˜å…ˆçº§
- äº”è¿è·èƒœä¼˜å…ˆäºç¦æ‰‹
- é»‘æ£‹ç¦æ‰‹åªåœ¨éè·èƒœæƒ…å†µä¸‹ç”Ÿæ•ˆ
- ç™½æ£‹æ— ä»»ä½•ç¦æ‰‹é™åˆ¶

### 4. æµ‹è¯•è¦ç‚¹
- æ‰€æœ‰ç¦æ‰‹å½¢æ€çš„æ­£ç¡®æ£€æµ‹
- è¾¹ç•Œä½ç½®çš„è§„åˆ™åˆ¤å®š
- AIç®—æ³•çš„åŸºæœ¬æ­£ç¡®æ€§
- æ€§èƒ½åŸºå‡†æµ‹è¯•

---

## ğŸ¯ AIéš¾åº¦è°ƒèŠ‚ç­–ç•¥

### è‡ªé€‚åº”éš¾åº¦ç³»ç»Ÿ
```javascript
class AdaptiveDifficulty {
    constructor() {
        this.playerStats = {
            wins: 0,
            losses: 0,
            draws: 0,
            avgGameLength: 0,
            recentPerformance: []
        };
        this.currentLevel = 'NORMAL';
    }
    
    updateAfterGame(result, gameLength) {
        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        this.playerStats.recentPerformance.push(result);
        if (this.playerStats.recentPerformance.length > 10) {
            this.playerStats.recentPerformance.shift();
        }
        
        // è®¡ç®—æœ€è¿‘èƒœç‡
        const recentWinRate = this.calculateRecentWinRate();
        
        // è°ƒæ•´éš¾åº¦
        if (recentWinRate > 0.7) {
            this.increaseDifficulty();
        } else if (recentWinRate < 0.3) {
            this.decreaseDifficulty();
        }
    }
    
    increaseDifficulty() {
        const levels = ['BEGINNER', 'NORMAL', 'HARD', 'HELL'];
        const currentIndex = levels.indexOf(this.currentLevel);
        if (currentIndex < levels.length - 1) {
            this.currentLevel = levels[currentIndex + 1];
        }
    }
    
    decreaseDifficulty() {
        const levels = ['BEGINNER', 'NORMAL', 'HARD', 'HELL'];
        const currentIndex = levels.indexOf(this.currentLevel);
        if (currentIndex > 0) {
            this.currentLevel = levels[currentIndex - 1];
        }
    }
}
```

### æ•™å­¦è¾…åŠ©ç³»ç»Ÿ
```javascript
class AITeacher {
    // åˆ†æå¹¶è§£é‡ŠAIçš„ç§»åŠ¨
    explainMove(board, move, level) {
        const analysis = this.analyzeMove(board, move);
        
        switch(level) {
            case 'BEGINNER':
                return this.basicExplanation(analysis);
            case 'NORMAL':
                return this.tacticalExplanation(analysis);
            case 'HARD':
                return this.strategicExplanation(analysis);
            case 'HELL':
                return this.expertExplanation(analysis);
        }
    }
    
    // ä¸ºç©å®¶æä¾›æç¤º
    provideHint(board, player, level) {
        const threats = this.findPlayerThreats(board, player);
        const opportunities = this.findOpportunities(board, player);
        
        return {
            immediate: threats.filter(t => t.urgent),
            opportunities: opportunities,
            suggestion: this.suggestMove(board, player, level)
        };
    }
}
```

### æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
```javascript
class AIPerformanceMonitor {
    constructor() {
        this.metrics = {
            responseTime: [],
            nodesSearched: [],
            accuracy: [],
            memoryUsage: []
        };
    }
    
    recordPerformance(level, responseTime, nodesSearched, accuracy) {
        this.metrics.responseTime.push({ level, value: responseTime });
        this.metrics.nodesSearched.push({ level, value: nodesSearched });
        this.metrics.accuracy.push({ level, value: accuracy });
        
        // æ£€æŸ¥æ˜¯å¦è¶…å‡ºæ€§èƒ½é™åˆ¶
        if (responseTime > AILevels[level].responseTime) {
            console.warn(`AI ${level} å“åº”æ—¶é—´è¶…é™: ${responseTime}ms`);
        }
    }
    
    getPerformanceReport() {
        return {
            avgResponseTime: this.calculateAverage(this.metrics.responseTime),
            avgNodesSearched: this.calculateAverage(this.metrics.nodesSearched),
            avgAccuracy: this.calculateAverage(this.metrics.accuracy),
            recommendations: this.generateOptimizationSuggestions()
        };
    }
}
```

---

*æœ¬æ–‡æ¡£æ•´åˆäº†äº”å­æ£‹çš„æ ¸å¿ƒè§„åˆ™çŸ¥è¯†å’Œå››çº§AIç®—æ³•å®ç°ï¼Œä¸ºæ–°é¡¹ç›®å¼€å‘æä¾›å®Œæ•´çš„æŠ€æœ¯å‚è€ƒã€‚AIéš¾åº¦ç­‰çº§ç³»ç»ŸåŸºäºç°ä»£äº”å­æ£‹AIç ”ç©¶æˆæœï¼Œèƒ½å¤Ÿä¸ºä¸åŒæ°´å¹³çš„ç©å®¶æä¾›åˆé€‚çš„æŒ‘æˆ˜ã€‚*